[["index.html", "R for Data Journalism About", " R for Data Journalism HSIEH, JI-LUNG 2023-01-30 About 這本書是寫給臺大新聞所「新聞資料分析與視覺化」課程使用。該課程並重三個面向的訓練：程式語言、視覺化、資料新聞。學生必須先能夠熟練地使用R語言來操作、讀取、清理、視覺化資料；然後以產製新聞為課程目標，了解資料要如何清理，以及選擇適合的視覺化的方法來強化新聞敘事，並避免視覺化方式引起讀者對新聞的理解謬誤。準此，本書分為幾個部分，包含PART I介紹程式語言基礎；PART II則以國際或國內新聞為個案，來介紹資料獲取（爬蟲）、清理、合併、篩選、轉換；PART III則著重如何用資料視覺化來強化敘事。 本書所沿用的資料分析與視覺化案例均為國內、國外的新聞案例如各國產假支薪等級、居住正義、空氣污染、人口議題、COVID-19、資源區域分佈不均、選舉與公投、運輸交通等相關議題的新聞。並大量採用紐約時報挑選作為數據理解與視覺化推廣的「What’s going on in this graph?」系列新聞，包含美國不同年代各年齡層的淨資產來做視覺化案例。在視覺化教材的設計上，本書大量參考紐時「What’s going on in this graph?」的分類與(Wilke 2019)所著「Fundamentals of Data Visualization」一書的內容安排，強調利用資料視覺化方法來呈現新聞數據中的數量、分佈、比例、趨勢等，並均換用國內或紐時的相關資料新聞案例做範例，以利中文讀者的理解。 學習路徑 References "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction "],["basic.html", "Chapter 2 R Basic 2.1 使用RStudio 2.2 第一次資料嘗試 2.3 R Q&amp;A", " Chapter 2 R Basic The chapter introduces how to use RStudio to write and execute R programming language. It will also briefly introduce the basic syntax of R, as well as the vector and data.frame data types. 2.1 使用RStudio 2.1.1 RStudio介面簡介 RStudio的介面主要分為四大區塊，左上的區塊是「Source」（或現在可切換至「Visual」）是撰寫程式碼與R Markdown的區塊；每行程式碼的執行和執行結果都會出現在左下「Console」的區塊；右上角區塊最常用的是「Environment」這個分頁，程式碼執行過程產生的變數／變項都會出現在這裡。右下角區塊我最常用的是「Files」這個分頁，顯示的是我自己電腦本機端的檔案目錄。右下角區塊也常常用到「Packages」，可查閱現在的程式執行環境有載入哪些套件；當用help(some_function)查詢某個套件或某個函式的功能是，就會自動跳到「Help」分頁。 2.1.2 用RMarkdown來撰寫R R Markdown這種格式讓程式寫作者可以將程式碼和非程式碼的內容寫在同一份文件中。例如我想要寫作一本關於程式的書，裡面有很多的程式碼，但也要有很多說明、章節與段落。此時，這些非程式碼的區塊通常被稱為「Text Cell」，而程式碼的區塊就稱為「Code Cell」。尤其是資料分析師或資料科學家很愛用這種格式，因為經常要為程式的執行結果寫很多說明，甚至利用標題一、標題二來區分章節。 R Markdown格式，顧名思義，支援用Markdown這種標記語法來快速撰寫如標題一、標題二、點列、編號等格式化文字。詳細指令可以參考rmarkdown-cheatsheet (rstudio.com)。 2.1.3 撰寫R Now try to run the following code with these keyboard operations: Using Cmd+Enter (Ctrl+Enter in Window) to execute the line where your cursor is located. Using Cmd(Ctrl)+Shift+Enter to run all code in a cell Using mouse to select multiple lines, then Cmd(Ctrl)+Shift+c to comment/un-comment multiple lines. Using Cmd(Ctrl)+Option(Alt)+i to insert a new cell a &lt;- c(1, 2, 3, 4, 5) b &lt;- 4 a*b ## [1] 4 8 12 16 20 2.1.4 安裝並載入第三方套件 套件的使用分為安裝(install.packages(\"pkg_name\"))和載入（library(pkg_name)）兩個動作。通常安裝好R的時候就已經安裝好基本base套件。當執行R時便會將base套件預載入程式的執行環境中。 非常多的R使用者會編寫第三方套件，並且將這些套件開放給群眾使用。通常這些套件已經被上載到R cran提供下載。而R cran上的套件我們可以使用install.packages(\"package_name\")來自動安裝到我們的電腦中。 Practice 1. Run the following code to install these R packages。 2.1.4.1 載入套件 After these third-party packages are installed, they need to be loaded into the program’s runtime environment before they can be used. So you need to load them with library(package_name). library(tidyverse) library(jsonlite) library(httr) 2.1.5 程式碼註解 下列程式碼中開頭有#符號者為註解，程式設計師用這種註解來為程式碼做說明，便於自己日後閱讀或與他人溝通。程式在執行時會自動忽略前面有#符號的程式碼。如果要執行以下程式碼，要把前面的#記號給拿掉。在RStudio中你可以用滑鼠或鍵盤圈選下三行，然後用快速鍵command(ctrl)+shift+c就可以開關（Comment/Un-comment)這幾行程式碼。 # a &lt;- c(1, 2, 3, 4, 5) # b &lt;- 4 # a*b 2.2 第一次資料嘗試 2.2.1 讀取台北住宅竊盜點位資料 Go to data.taipei Make a query “住宅竊盜” Open “住宅竊盜點位資訊” Click “API” Copy the API address and assign to url 2.2.2 讀取先行下載的csv檔 df &lt;- read.csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;) head(df) 編號 案類 發生日期 發生時段 發生地點 1 住宅竊盜 1030623 08~10 臺北市中正區廈門街91~120號 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 4 住宅竊盜 1040101 06~08 臺北市中山區新生北路1段91~120號 5 住宅竊盜 1040101 10~12 臺北市文山區明興里興隆路4段1~30號 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 2.2.3 直接從網路載入內政部開放資料 library(httr) library(jsonlite) url &lt;- &quot;https://www.ris.gov.tw/rs-opendata/api/v1/datastore/ODRP024/107?page=1&quot; first_page &lt;- fromJSON(content(GET(url), &quot;text&quot;)) # head(first_page$responseData) head(first_page$responseData) %&gt;% rename(戶長=headhousehold_count) statistic_yyy district_code site_id village edu sex 戶長 107 65000010001 新北市板橋區 留侯里 博畢 男 3 107 65000010001 新北市板橋區 留侯里 碩畢 男 26 107 65000010001 新北市板橋區 留侯里 大畢 男 71 107 65000010001 新北市板橋區 留侯里 專畢 男 52 107 65000010001 新北市板橋區 留侯里 高中畢 男 122 107 65000010001 新北市板橋區 留侯里 國中畢 男 40 2.2.4 獲取ubike即時資料 https://taipeicity.github.io/traffic_realtime/ url &lt;- &quot;https://tcgbusfs.blob.core.windows.net/blobyoubike/YouBikeTP.json&quot; ubike.list &lt;- fromJSON(content(GET(url),&quot;text&quot;, encoding = &quot;utf-8&quot;)) ubike.v &lt;- unlist(ubike.list$retVal) ubike.m &lt;- matrix(ubike.v, byrow = T, ncol = 14) ubike.df &lt;- as.data.frame(ubike.m) names(ubike.df) &lt;- names(ubike.list$retVal$`0001`) head(ubike.df) %&gt;% select(1:6) sno sna tot sbi sarea mday 0001 捷運市政府站(3號出口) 88 71 信義區 20221014150033 0002 捷運國父紀念館站(2號出口) 16 6 大安區 20221014150018 0004 市民廣場 32 32 信義區 20221014150038 0005 興雅國中 32 20 信義區 20221014150027 0006 臺北南山廣場 54 19 信義區 20221014150015 0007 信義廣場(台北101) 40 20 信義區 20221014150043 2.3 R Q&amp;A 2.3.1 編碼與設定語系 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;UTF-8&quot;) Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;cht&quot;) 如果讀取到資料有中文的話，此時，你只需要指定locale為cht，然後重開該data.frame就可以解決該問題。 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;cht&quot;) 但你在寫程式剖析HTML時若使用了rvest這個套件，有可能在html_node()函式時會因為編碼而產生問題，此時你會需要把locale改為C。這個C指的是C語言的C。 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;C&quot;) 參考連結：http://psmethods.postach.io/post/ru-he-geng-gai-rde-yu-she-yu-xi 參考連結：https://stat.ethz.ch/R-manual/R-devel/library/base/html/locales.html The locale describes aspects of the internationalization of a program. Initially most aspects of the locale of R are set to “C” (which is the default for the C language and reflects North-American usage) 2.3.2 RMD/R Notebook無法儲存 R Notebook 要存檔的時候檔名絕對不要有空白，若有空白就用底線_代替，否則Notebook寫到一半會無法預覽下半部的程式並出現錯誤訊息。若仍然無法儲存或出現錯誤訊息，應該只要開另外一個R Notebook檔案，複製程式碼即可。 "],["r-basic.html", "Chapter 3 R Basic 3.1 R Syntax 3.2 Vector 3.3 Calculating with vectors 3.4 Data types 3.5 Character operations", " Chapter 3 R Basic 3.1 R Syntax 3.1.1 Assignment &lt;- 將右邊的算式或數值指派給左邊的變數。右邊如果是numeric，那左邊的變數就是numeric variable；右邊如果是character，左邊的變數就是character variable。 在幾乎所有程式語言中，單等號=指的是assignment，把右方的算式、值或物件指給左方的變數。而比較兩者相不相等，則用雙等號==，例如1==3-2。 a &lt;- 1 b &lt;- c(1, 2, 3, 4) c &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) d &lt;- c(b, a) e &lt;- &quot;abcd&quot; 3.1.2 Comments 註解 註解：在程式碼區塊若前面有#字號後面跟著空白的話，那代表那行被標示為註解，程式執行時會自動跳過註解不執行。 快速鍵：當游標在某一行程式碼時打cmd(ctrl)-shift-c，就可以產生註解。 # df &lt;- data.frame(a = c(1, 2, 3), b = c(3, 4, 5)) 3.2 Vector Vector是R語言最基本的 各縣市平均每月薪資所得 各縣市人口數 3.2.1 Creating vectors 在程式碼中，只要是文字必用成對的雙引號或單引號包含其中，以區隔「變數」和「數字」。例如如果看到沒有雙引號的「英文字母」必定是變數名稱，或函式名稱。 如果看到有雙引號的數字，那也是文字。 income &lt;- c(70100, 51300, 51100, 48400, 47600, 43000) county &lt;- c(&quot;台北&quot;, &quot;新北&quot;, &quot;桃園&quot;, &quot;高雄&quot;, &quot;台中&quot;, &quot;台南&quot;) population &lt;- c(2.6, 3.9, 2.2, 2.7, 2.8, 1.8) area &lt;- c(271.8, 2052.5, 1221, 2951.9, 2214.9, 2191.7) income ## [1] 70100 51300 51100 48400 47600 43000 county[c(5, 3, 1)] ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; county &lt;- county[c(5, 3, 1)] county ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; area ## [1] 271.8 2052.5 1221.0 2951.9 2214.9 2191.7 population ## [1] 2.6 3.9 2.2 2.7 2.8 1.8 3.2.1.1 Creating a sequence a &lt;- seq(11, 99, 11) a ## [1] 11 22 33 44 55 66 77 88 99 b &lt;- 11:20 b ## [1] 11 12 13 14 15 16 17 18 19 20 3.2.1.2 Creating sequences by distribution x &lt;- runif(10000000, 1, 10) # uniform dist, n=1000 plot(density(x)) x &lt;- rnorm(1000, 1, 10) # uniform dist, n=1000 plot(density(x)) x &lt;- rnorm(10000000, 1, 10) # normal dist, n=1000 plot(density(x)) 3.2.2 Viewing county ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; income ## [1] 70100 51300 51100 48400 47600 43000 head(county) ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; tail(county) ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; length(county) ## [1] 3 mode(county) ## [1] &quot;character&quot; class(county) ## [1] &quot;character&quot; # View(county) length(county) ## [1] 3 length(income) ## [1] 6 3.2.3 Subsetting, filtering It is important to know how to neglect first n or last n elements. For example, a[1:(length(a)-2)] will neglect the last two elements. Thinking why I need parentheses for length(a)-2 here. county ## [1] &quot;台中&quot; &quot;桃園&quot; &quot;台北&quot; county[c(5, 3, 1)] # how about country[c(1, 3, 5)] ## [1] NA &quot;台北&quot; &quot;台中&quot; county[3:6] # is it equal to country[c(3, 4, 5, 6)] ## [1] &quot;台北&quot; NA NA NA a &lt;- 11:19 a[3:length(a)] ## [1] 13 14 15 16 17 18 19 a[length(a):3] ## [1] 19 18 17 16 15 14 13 3.2.4 Deleting Without assignment, deletion won’t change original vectors b &lt;- 11:20 b[-(3:5)] ## [1] 11 12 16 17 18 19 20 b[-c(1, 3, 5)] ## [1] 12 14 16 17 18 19 20 b ## [1] 11 12 13 14 15 16 17 18 19 20 Correct deleting operations with assignment to replace original vector b &lt;- b[-(3:5)] b ## [1] 11 12 16 17 18 19 20 a &lt;- seq(11, 99, 11) a &lt;- a[-c(1, 3, 5)] a ## [1] 22 44 66 77 88 99 3.2.5 Concatinating Concatinating is quite useful for web crawling when you crawl article links page by page. You may be not sure the number of page you need to crawl. So you need to append entire new vector to old vector. It is concatinating. (“Appending” often means adding one new element at the end of data.) a &lt;- 1:10 a &lt;- c(a, 11) a ## [1] 1 2 3 4 5 6 7 8 9 10 11 b ## [1] 11 12 16 17 18 19 20 a &lt;- c(a, b) a ## [1] 1 2 3 4 5 6 7 8 9 10 11 11 12 16 17 18 19 20 a &lt;- c(a, a, b) a ## [1] 1 2 3 4 5 6 7 8 9 10 11 11 12 16 17 18 19 20 1 2 3 4 5 6 7 ## [26] 8 9 10 11 11 12 16 17 18 19 20 11 12 16 17 18 19 20 3.3 Calculating with vectors 3.3.1 Arithmetic operations a &lt;- 11:19 a + 3 ## [1] 14 15 16 17 18 19 20 21 22 a / 2 ## [1] 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 a %% 2 ## [1] 1 0 1 0 1 0 1 0 1 a %/% 2 ## [1] 5 6 6 7 7 8 8 9 9 a %% 2== 0 ## [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE which(a %% 2== 0) ## [1] 2 4 6 8 a[which(a%% 2 == 0)] ## [1] 12 14 16 18 a[c(2, 4, 6, 8)] ## [1] 12 14 16 18 a %% 2 != 0 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE a[a%% 2 == 0] ## [1] 12 14 16 18 a[a%%2 != 0] ## [1] 11 13 15 17 19 a &lt;- a %% 2 # modular arithmetic, get the reminder a &lt;- a %/% 2 # Quotient 3.3.2 Logic comparisons a %% 2 == 0 # deteting odd/even number ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE a %% 2 != 0 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE a[a%%2==0] ## [1] 0 0 0 0 0 0 0 0 0 a &gt; b ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE income &gt; mean(income) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE TRUE == T # == equal to, ## [1] TRUE TRUE != F # != Not equal to ## [1] TRUE any(a&gt;11) # is there any element larger than 1 ## [1] FALSE all(a&gt;11) # are all elements larger than 1 ## [1] FALSE 3.3.3 Subsetting by logic comparisons two methods to filter data from vectors, by index vector or a logical vector with equal length. a &lt;- seq(11, 55, 11) a[c(T, F, T, F, T)] ## [1] 11 33 55 a[a%%2==1] ## [1] 11 33 55 a%%2 ## [1] 1 0 1 0 1 a%%2==1 ## [1] TRUE FALSE TRUE FALSE TRUE a &lt;- c(&quot;你好&quot;,&quot;你好棒棒&quot;,&quot;你好棒&quot;,&quot;你真的好棒&quot;) a[nchar(a)&gt;3] ## [1] &quot;你好棒棒&quot; &quot;你真的好棒&quot; # which will return &quot;index-of&quot; a &lt;- seq(11, 55, 11) a[which(a%%2==1)] ## [1] 11 33 55 which(a%%2==1) ## [1] 1 3 5 3.3.4 Sorting and ordering sort(x)的結果必須用&lt;-覆蓋原本的x，此時的x才算被排序的結果。 order(x)函式會傳回x數值由小到大的索引。這個例子的結果是5, 4, 3, 6, 1, 2，也就是5位置的那個數最小、4那個位置的數次小、接下來3, 6, 1, 2。 x[order(x)]把order(x)結果（也就是c(5, 4, 3, 6, 1, 2)）傳給原本的x便會使得原本的x重新排序。通常order()的用途是，我們可以將兩個等長的variables例如var1和var2，依據var2來重新排序var1，例如var1[order(var2)]。 x &lt;- c(33, 55, 22, 13, 4, 24) mode(x) ## [1] &quot;numeric&quot; class(x) ## [1] &quot;numeric&quot; sort(x) ## [1] 4 13 22 24 33 55 # x &lt;- sort(x) # assign to replace original x order(x) ## [1] 5 4 3 6 1 2 x[order(x)] ## [1] 4 13 22 24 33 55 x[c(5, 4, 3, 6, 1, 2)] ## [1] 4 13 22 24 33 55 3.3.5 Built-in math functions a &lt;- 11:19 min(a); max(a); mean(a); median(a); sd(a) ## [1] 11 ## [1] 19 ## [1] 15 ## [1] 15 ## [1] 2.738613 log2(a) ## [1] 3.459432 3.584963 3.700440 3.807355 3.906891 4.000000 4.087463 4.169925 ## [9] 4.247928 log1p(a) ## [1] 2.484907 2.564949 2.639057 2.708050 2.772589 2.833213 2.890372 2.944439 ## [9] 2.995732 ?log1p log R Documentation Logarithms and Exponentials Description log computes logarithms, by default natural logarithms, log10 computes common (i.e., base 10) logarithms, and log2 computes binary (i.e., base 2) logarithms. The general form log(x, base) computes logarithms with base base. log1p(x) computes (1+x) accurately also for |x| . exp computes the exponential function. expm1(x) computes (x) - 1 accurately also for |x| . Usage log(x, base = exp(1)) logb(x, base = exp(1)) log10(x) log2(x) log1p(x) exp(x) expm1(x) Arguments x a numeric or complex vector. base a positive or complex number: the base with respect to which logarithms are computed. Defaults to e=exp(1). Details All except logb are generic functions: methods can be defined for them individually or via the Math group generic. log10 and log2 are only convenience wrappers, but logs to bases 10 and 2 (whether computed via log or the wrappers) will be computed more efficiently and accurately where supported by the OS. Methods can be set for them individually (and otherwise methods for log will be used). logb is a wrapper for log for compatibility with S. If (S3 or S4) methods are set for log they will be dispatched. Do not set S4 methods on logb itself. All except log are primitive functions. Value A vector of the same length as x containing the transformed values. log(0) gives -Inf, and log(x) for negative values of x is NaN. exp(-Inf) is 0. For complex inputs to the log functions, the value is a complex number with imaginary part in the range [-, ]: which end of the range is used might be platform-specific. S4 methods exp, expm1, log, log10, log2 and log1p are S4 generic and are members of the Math group generic. Note that this means that the S4 generic for log has a signature with only one argument, x, but that base can be passed to methods (but will not be used for method selection). On the other hand, if you only set a method for the Math group generic then base argument of log will be ignored for your class. Source log1p and expm1 may be taken from the operating system, but if not available there then they are based on the Fortran subroutine dlnrel by W. Fullerton of Los Alamos Scientific Laboratory (see https://www.netlib.org/slatec/fnlib/dlnrel.f) and (for small x) a single Newton step for the solution of log1p(y) = x respectively. References Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. (for log, log10 and exp.) Chambers, J. M. (1998) Programming with Data. A Guide to the S Language. Springer. (for logb.) See Also Trig, sqrt, Arithmetic. Examples log(exp(3)) log10(1e7) # = 7 x &lt;- 10^-(1+2*1:9) cbind(x, log(1+x), log1p(x), exp(x)-1, expm1(x)) 3.4 Data types 3.4.1 Checking data type mode(county) # character ## [1] &quot;character&quot; mode(income) # numeric ## [1] &quot;numeric&quot; mode(income &gt; mean(income)) # logical ## [1] &quot;logical&quot; testing &lt;- c(&quot;26.142&quot;, &quot;12.008&quot;, &quot;7.032&quot;, &quot;13.646&quot;, &quot;4.589&quot;) mode(testing) # character ## [1] &quot;character&quot; 3.4.2 Converting data type numeric vector可以用as.character(x)轉成charcter；logical vector可以用as.numeric(x)轉為numeric。概念上可以說是character &gt; numeric &gt; logical。 如果硬是在logical vector後附加一個numeric element的話，那就會整個vector被轉為numeric vector；相仿地，如果numeric vector後附加一個character element的話那整個vector就會被轉為character vector。 可以用sum()函式來計算logical vector有幾個TRUE值。例如sum(a%%2==1)就是計算a中有幾個奇數。TRUE可視為1、FALSE可視為0，所以加總起來就是TRUE有幾個。 income.c &lt;- as.character(income) population.c &lt;- as.numeric(population) a &lt;- seq(11, 99, 11) a &lt;- c(a, &quot;100&quot;) a &lt;- seq(11, 99, 11) sum(a%%2==1) ## [1] 5 max(a) ## [1] 99 3.5 Character operations a &lt;- seq(11, 55, 11) paste(&quot;A&quot;, a) # concatenate ## [1] &quot;A 11&quot; &quot;A 22&quot; &quot;A 33&quot; &quot;A 44&quot; &quot;A 55&quot; paste0(&quot;A&quot;, a) # concatenate ## [1] &quot;A11&quot; &quot;A22&quot; &quot;A33&quot; &quot;A44&quot; &quot;A55&quot; "],["dataframe.html", "Chapter 4 Dataframe 4.1 基本操作 4.2 簡易繪圖 4.3 基本操作：使用dplyr 4.4 tibble, data_frame, data.frame 4.5 Database - SQLite", " Chapter 4 Dataframe 4.1 基本操作 4.1.1 產生新的Dataframe 4.1.1.1 複製資料至vector 直接複製Wikipedia上的台北市某五區人口資料 population &lt;- c(158228, 126687, 228075, 204903, 308383, 187920) town &lt;- c(&quot;中正&quot;, &quot;大同&quot;, &quot;中山&quot;, &quot;松山&quot;, &quot;大安&quot;, &quot;萬華&quot;) area &lt;- c(7.6071, 5.6815, 13.6821, 9.2878, 11.3614, 8.8522) 4.1.1.2 合併等長vector為dataframe df &lt;- data.frame(town, population, area) df$density = df$population / df$area str(df) ## &#39;data.frame&#39;: 6 obs. of 4 variables: ## $ town : chr &quot;中正&quot; &quot;大同&quot; &quot;中山&quot; &quot;松山&quot; ... ## $ population: num 158228 126687 228075 204903 308383 ... ## $ area : num 7.61 5.68 13.68 9.29 11.36 ... ## $ density : num 20800 22298 16670 22062 27143 ... summary(df) town population area density Length:6 Min. :126687 Min. : 5.681 Min. :16670 Class :character 1st Qu.:165651 1st Qu.: 7.918 1st Qu.:20907 Mode :character Median :196412 Median : 9.070 Median :21645 NA Mean :202366 Mean : 9.412 Mean :21700 NA 3rd Qu.:222282 3rd Qu.:10.843 3rd Qu.:22239 NA Max. :308383 Max. :13.682 Max. :27143 # View(df) 4.1.1.3 存放台灣貿易各國進出口量 運用台灣出口進口資料 台灣出口進口貿易資料查詢 country &lt;- c(&quot;CN&quot;, &quot;US&quot;, &quot;JP&quot;, &quot;HK&quot;, &quot;KR&quot;, &quot;SG&quot;, &quot;DE&quot;, &quot;MY&quot;, &quot;VN&quot;, &quot;PH&quot;, &quot;TH&quot;, &quot;AU&quot;, &quot;NL&quot;, &quot;SA&quot;, &quot;ID&quot;, &quot;GB&quot;, &quot;IN&quot;, &quot;FR&quot;, &quot;IT&quot;, &quot;AE&quot;) import &lt;- c(26.142, 12.008, 7.032, 13.646, 4.589, 5.768, 2.131, 2.802, 3.428, 3.019, 1.976, 1.118, 1.624, 0.449, 0.983, 1.302, 1.027, 0.553, 0.670, 0.455) export &lt;- c(22.987, 12.204, 11.837, 7.739, 5.381, 4.610, 2.866, 2.784, 2.414, 2.092, 1.839, 1.788, 1.665, 1.409, 1.391, 1.075, 0.974, 0.899, 0.800, 0.728) 4.1.1.4 合併vector為data.frame 這時候我們若以str(df)觀察該df的結構會發現，文字型態的資料被轉為Factors，這是我們所不樂見的。過去統計通常會把文字型態當成類別變數，於是用Factors作為資料型態，但資料科學中經常要處理大量的文字資料，此時，我們可以把read.csv的一個參數stringsAsFactors設為FALSE，意味著預設不要將文字的資料轉為Factor而是直接以文字變項來處理。* stringsAsFactors = FALSE也是read.csv()的參數（parameter、argument）。因為一般讀檔會預設把文字讀為類別變項也就是Factor，但資料分析經常要處理文字資料而不是類別變項，所以會希望預設不要把文字讀取為類別變項，因此要設定stringsAsFactors = FALSE。 為了避免每次都要打這串參數，可以把它設定為全域參數，可以在程式一開始時便加上options(stringsAsFactors = FASLE)，意味著底下所有的函式如果有stringsAsFactors這個參數，一律自動設為FALSE。 df &lt;- data.frame(country, import, export) str(df) ## &#39;data.frame&#39;: 20 obs. of 3 variables: ## $ country: chr &quot;CN&quot; &quot;US&quot; &quot;JP&quot; &quot;HK&quot; ... ## $ import : num 26.14 12.01 7.03 13.65 4.59 ... ## $ export : num 22.99 12.2 11.84 7.74 5.38 ... df &lt;- data.frame(country, import, export, stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 20 obs. of 3 variables: ## $ country: chr &quot;CN&quot; &quot;US&quot; &quot;JP&quot; &quot;HK&quot; ... ## $ import : num 26.14 12.01 7.03 13.65 4.59 ... ## $ export : num 22.99 12.2 11.84 7.74 5.38 ... 甚至也可以建立一個新的、空的data.frame。 df.test就R的用法就是一個變數，並不是df和test各自是一個變數。 df.test &lt;- data.frame() 4.1.2 觀察dataframe View(df) 用RStudio所提供的GUI直接觀看變數 head(df) 取前面六筆資料（也就是六列的資料來概觀該資料） class(df) str(df) summary(df) # View(df) head(df) # get first part of the data.frame country import export CN 26.142 22.987 US 12.008 12.204 JP 7.032 11.837 HK 13.646 7.739 KR 4.589 5.381 SG 5.768 4.610 class(df) ## [1] &quot;data.frame&quot; str(df) ## &#39;data.frame&#39;: 20 obs. of 3 variables: ## $ country: chr &quot;CN&quot; &quot;US&quot; &quot;JP&quot; &quot;HK&quot; ... ## $ import : num 26.14 12.01 7.03 13.65 4.59 ... ## $ export : num 22.99 12.2 11.84 7.74 5.38 ... summary(df) country import export Length:20 Min. : 0.449 Min. : 0.728 Class :character 1st Qu.: 1.016 1st Qu.: 1.312 Mode :character Median : 2.054 Median : 1.966 NA Mean : 4.536 Mean : 4.374 NA 3rd Qu.: 4.884 3rd Qu.: 4.803 NA Max. :26.142 Max. :22.987 # look up help help(summary) summary R Documentation Object Summaries Description summary is a generic function used to produce result summaries of the results of various model fitting functions. The function invokes particular methods which depend on the class of the first argument. Usage summary(object, ...) ## Default S3 method: summary(object, ..., digits, quantile.type = 7) ## S3 method for class 'data.frame' summary(object, maxsum = 7, digits = max(3, getOption(\"digits\")-3), ...) ## S3 method for class 'factor' summary(object, maxsum = 100, ...) ## S3 method for class 'matrix' summary(object, ...) ## S3 method for class 'summaryDefault' format(x, digits = max(3L, getOption(\"digits\") - 3L), ...) ## S3 method for class 'summaryDefault' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...) Arguments object an object for which a summary is desired. x a result of the default method of summary(). maxsum integer, indicating how many levels should be shown for factors. digits integer, used for number formatting with signif() (for summary.default) or format() (for summary.data.frame). In summary.default, if not specified (i.e., missing(.)), signif() will not be called anymore (since R &gt;= 3.4.0, where the default has been changed to only round in the print and format methods). quantile.type integer code used in quantile(*, type=quantile.type) for the default method. … additional arguments affecting the summary produced. Details For factors, the frequency of the first maxsum - 1 most frequent levels is shown, and the less frequent levels are summarized in “(Others)” (resulting in at most maxsum frequencies). The functions summary.lm and summary.glm are examples of particular methods which summarize the results produced by lm and glm. Value The form of the value returned by summary depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method. The default method returns an object of class c(“summaryDefault”, “table”) which has specialized format and print methods. The factor method returns an integer vector. The matrix and data frame methods return a matrix of class “table”, obtained by applying summary to each column and collating the results. References Chambers, J. M. and Hastie, T. J. (1992) Statistical Models in S. Wadsworth &amp; Brooks/Cole. See Also anova, summary.glm, summary.lm. Examples summary(attenu, digits = 4) #-&gt; summary.data.frame(...), default precision summary(attenu $ station, maxsum = 20) #-&gt; summary.factor(...) lst &lt;- unclass(attenu$station) &gt; 20 # logical with NAs ## summary.default() for logicals -- different from *.factor: summary(lst) summary(as.factor(lst)) ?summary summary R Documentation Object Summaries Description summary is a generic function used to produce result summaries of the results of various model fitting functions. The function invokes particular methods which depend on the class of the first argument. Usage summary(object, ...) ## Default S3 method: summary(object, ..., digits, quantile.type = 7) ## S3 method for class 'data.frame' summary(object, maxsum = 7, digits = max(3, getOption(\"digits\")-3), ...) ## S3 method for class 'factor' summary(object, maxsum = 100, ...) ## S3 method for class 'matrix' summary(object, ...) ## S3 method for class 'summaryDefault' format(x, digits = max(3L, getOption(\"digits\") - 3L), ...) ## S3 method for class 'summaryDefault' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...) Arguments object an object for which a summary is desired. x a result of the default method of summary(). maxsum integer, indicating how many levels should be shown for factors. digits integer, used for number formatting with signif() (for summary.default) or format() (for summary.data.frame). In summary.default, if not specified (i.e., missing(.)), signif() will not be called anymore (since R &gt;= 3.4.0, where the default has been changed to only round in the print and format methods). quantile.type integer code used in quantile(*, type=quantile.type) for the default method. … additional arguments affecting the summary produced. Details For factors, the frequency of the first maxsum - 1 most frequent levels is shown, and the less frequent levels are summarized in “(Others)” (resulting in at most maxsum frequencies). The functions summary.lm and summary.glm are examples of particular methods which summarize the results produced by lm and glm. Value The form of the value returned by summary depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method. The default method returns an object of class c(“summaryDefault”, “table”) which has specialized format and print methods. The factor method returns an integer vector. The matrix and data frame methods return a matrix of class “table”, obtained by applying summary to each column and collating the results. References Chambers, J. M. and Hastie, T. J. (1992) Statistical Models in S. Wadsworth &amp; Brooks/Cole. See Also anova, summary.glm, summary.lm. Examples summary(attenu, digits = 4) #-&gt; summary.data.frame(...), default precision summary(attenu $ station, maxsum = 20) #-&gt; summary.factor(...) lst &lt;- unclass(attenu$station) &gt; 20 # logical with NAs ## summary.default() for logicals -- different from *.factor: summary(lst) summary(as.factor(lst)) 4.1.2.1 觀察資料維度 dim(df) ## [1] 20 3 ncol(df) ## [1] 3 nrow(df) ## [1] 20 length(df) ## [1] 3 4.1.3 操作dataframe 4.1.3.1 取出一個變項 names(df) 列出變數名稱 df$發生.現.地點 顯示該變數內容 df$發生時段 顯示該變數內容 length(df$發生時段) 顯示該變數的長度（相當於有幾個） names(df) ## [1] &quot;country&quot; &quot;import&quot; &quot;export&quot; head(df$發生.現.地點) ## NULL head(df$發生時段) ## NULL length(df$發生時段) ## [1] 0 summary(df) country import export Length:20 Min. : 0.449 Min. : 0.728 Class :character 1st Qu.: 1.016 1st Qu.: 1.312 Mode :character Median : 2.054 Median : 1.966 NA Mean : 4.536 Mean : 4.374 NA 3rd Qu.: 4.884 3rd Qu.: 4.803 NA Max. :26.142 Max. :22.987 4.1.3.2 (mutate)透過運算產生新變數 這裡容易犯錯的是，要記得跟程式講說你要加總或四則運算的是哪個df的variable。 從下面的這個操作中，該data.frame會產生一個新的變數sub，這就相當於Excel中的某一行減去某一行，然後把資料放在新的一行。 df$sub &lt;- df$import - df$export 4.1.3.3 (filter)篩選資料、選取變數 注意，要告訴程式import和export是哪個data.frame的。 df[,]為存取df中某個區段的數值或某個數值的方法。因此df[1, 1]會取出第一行第一列，也就是第一筆資料的第一個vector。df[2, 3]則會取出第二筆資料的第三個variable。 下面的例子nrow(df)為1894，有1894筆資料，所以自然df\\(import與df\\)export的長度都是1894。因此，比較這兩個變數的大小會得到一個長度為1894的boolean (logical) variable。因此把這個長度為1894、充滿TRUE和FALSE的logical vector丟進df的row之處，因為取自df，大小判斷式結果的長度自然和原本的df的列數相同。因此當這個TRUE/FALSE被丟在df的列之處，便會篩選出import大於p.xport的數值。 原本的df有五個variable，而上述的操作是篩選資料，所以被篩選的是列，因此行的數量、名稱都不會變。因此，我篩選完後，直接存取這個被篩選過的data.frame的country variable，自然是可以的。 df country import export sub CN 26.142 22.987 3.155 US 12.008 12.204 -0.196 JP 7.032 11.837 -4.805 HK 13.646 7.739 5.907 KR 4.589 5.381 -0.792 SG 5.768 4.610 1.158 DE 2.131 2.866 -0.735 MY 2.802 2.784 0.018 VN 3.428 2.414 1.014 PH 3.019 2.092 0.927 TH 1.976 1.839 0.137 AU 1.118 1.788 -0.670 NL 1.624 1.665 -0.041 SA 0.449 1.409 -0.960 ID 0.983 1.391 -0.408 GB 1.302 1.075 0.227 IN 1.027 0.974 0.053 FR 0.553 0.899 -0.346 IT 0.670 0.800 -0.130 AE 0.455 0.728 -0.273 names(df) ## [1] &quot;country&quot; &quot;import&quot; &quot;export&quot; &quot;sub&quot; nrow(df) ## [1] 20 # filter row data by column value df[df$import &gt; df$export,] country import export sub 1 CN 26.142 22.987 3.155 4 HK 13.646 7.739 5.907 6 SG 5.768 4.610 1.158 8 MY 2.802 2.784 0.018 9 VN 3.428 2.414 1.014 10 PH 3.019 2.092 0.927 11 TH 1.976 1.839 0.137 16 GB 1.302 1.075 0.227 17 IN 1.027 0.974 0.053 df[df$import &gt; df$export,]$country ## [1] &quot;CN&quot; &quot;HK&quot; &quot;SG&quot; &quot;MY&quot; &quot;VN&quot; &quot;PH&quot; &quot;TH&quot; &quot;GB&quot; &quot;IN&quot; df[df$import &gt; df$export,1] ## [1] &quot;CN&quot; &quot;HK&quot; &quot;SG&quot; &quot;MY&quot; &quot;VN&quot; &quot;PH&quot; &quot;TH&quot; &quot;GB&quot; &quot;IN&quot; # 1 row == a data.frame with only one data entry class(df[df$import &gt; df$export,1]) ## [1] &quot;character&quot; class(df[,1]) # character vector ## [1] &quot;character&quot; class(df[1,]) # data.frame ## [1] &quot;data.frame&quot; class(unlist(df[1, -1])) # filter the 1st row and select all columns except 1 ## [1] &quot;numeric&quot; 4.1.3.4 (arrange) 按某個變數排序 df.sorted &lt;- df[order(df$import),]會使得整個df照import的大小排序重新做排列。因為order(df$import)會把資料照指定順序排列後的位置傳回來，所以把他丟給df的列的位置，便會使得df的資料照指定的順序排列。 預設是由小到大，加上decreasing = T這個參數後變成由大而小。 # sort rows by df$import column df.sorted &lt;- df[order(df$import),] # View(df.sorted) # sort rows in decreasing order df.sorted &lt;- df[order(df$import, decreasing = T),] # add - to column in order() can sort in decreasing order df.sorted &lt;- df[order(-df$import),] head(df.sorted) country import export sub 1 CN 26.142 22.987 3.155 4 HK 13.646 7.739 5.907 2 US 12.008 12.204 -0.196 3 JP 7.032 11.837 -4.805 6 SG 5.768 4.610 1.158 5 KR 4.589 5.381 -0.792 4.2 簡易繪圖 graphics::plot()為會預載入R的繪圖套件，如果希望繪圖的同時加上回歸線和資料點標籤的話，必須要三行一起執行。 # plot(df) # raise error, 1st column is a character vector plot(df[, 2:3]) plot(df[1:10, 2:3]) text(import, export, labels=country, cex= 0.5, pos=3) lines(1:25, 1:25, col=&#39;red&#39;) ?plot ## Help on topic &#39;plot&#39; was found in the following packages: ## ## * base ## * graphics 4.3 基本操作：使用dplyr library(dplyr) df &lt;- data.frame(country, import, export, stringsAsFactors = F) df &lt;- mutate(df, sub = import - export) filter(df, import &gt; export) country import export sub CN 26.142 22.987 3.155 HK 13.646 7.739 5.907 SG 5.768 4.610 1.158 MY 2.802 2.784 0.018 VN 3.428 2.414 1.014 PH 3.019 2.092 0.927 TH 1.976 1.839 0.137 GB 1.302 1.075 0.227 IN 1.027 0.974 0.053 select(df, c(1, 3)) country export CN 22.987 US 12.204 JP 11.837 HK 7.739 KR 5.381 SG 4.610 DE 2.866 MY 2.784 VN 2.414 PH 2.092 TH 1.839 AU 1.788 NL 1.665 SA 1.409 ID 1.391 GB 1.075 IN 0.974 FR 0.899 IT 0.800 AE 0.728 message(df$country) print(df$country) ## [1] &quot;CN&quot; &quot;US&quot; &quot;JP&quot; &quot;HK&quot; &quot;KR&quot; &quot;SG&quot; &quot;DE&quot; &quot;MY&quot; &quot;VN&quot; &quot;PH&quot; &quot;TH&quot; &quot;AU&quot; &quot;NL&quot; &quot;SA&quot; &quot;ID&quot; ## [16] &quot;GB&quot; &quot;IN&quot; &quot;FR&quot; &quot;IT&quot; &quot;AE&quot; 4.4 tibble, data_frame, data.frame 警告： \"data_frame()\" was deprecated in tibble 1.1.0. Please use \"tibble()\" instead. df &lt;- data.frame(a=1:2, b=3:4, c=5:6) class(df) ## [1] &quot;data.frame&quot; df &lt;- data_frame(a=1:2, b=3:4, c=5:6) class(df) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; df &lt;- tibble(a=1:2, b=3:4, c=5:6) class(df) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 4.5 Database - SQLite "],["使用基礎r套件.html", "Chapter 5 使用基礎R套件 5.1 案例：產假支薪跨國跨時比較 5.2 計數與樞紐：台北住宅竊盜點位", " Chapter 5 使用基礎R套件 5.1 案例：產假支薪跨國跨時比較 本案例將利用R來重製華盛頓郵報在2016/08/13的一篇談論美國婦女產假支薪情形的報導。這個案例中將會應用到data.frame和基本的繪圖與資料摘要方法。The case adaped Washington Post’s paid maternity leave as an exmaple to introduce basic skill of data.frame, plotting, and data mamipulation. 原始新聞來源：https://www.washingtonpost.com/news/worldviews/wp/2016/08/13/the-world-is-getting-better-at-paid-maternity-leave-the-u-s-is-not/?tid=sm_tw&amp;utm_term=.f8cd50280326#comments 5.1.1 Reading .xlsx by readxl package readxl也包含在tidyverse的套件集中，所以應該已經在前次安裝過，不用特別安裝。 # Import readxl package library(readxl) options(stringsAsFactors = FALSE) # Use read_excel() to convert excel sheet to data.frame df &lt;- read_excel(&quot;data/WORLD-MACHE_Gender_6.8.15.xls&quot;, &quot;Sheet1&quot;, col_names=T) 5.1.2 Previewing data by View(), class(), dim(), str(), summary() and names() # View(df) class(df) # [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(df) ## [1] 197 156 # Show names of variables (vectors, columns) by names() names(df) ## [1] &quot;country&quot; &quot;iso2&quot; &quot;iso3&quot; ## [4] &quot;region&quot; &quot;wb_econ&quot; &quot;matleave_95&quot; ## [7] &quot;matleave_96&quot; &quot;matleave_97&quot; &quot;matleave_98&quot; ## [10] &quot;matleave_99&quot; &quot;matleave_00&quot; &quot;matleave_01&quot; ## [13] &quot;matleave_02&quot; &quot;matleave_03&quot; &quot;matleave_04&quot; ## [16] &quot;matleave_05&quot; &quot;matleave_06&quot; &quot;matleave_07&quot; ## [19] &quot;matleave_08&quot; &quot;matleave_09&quot; &quot;matleave_10&quot; ## [22] &quot;matleave_11&quot; &quot;matleave_12&quot; &quot;matleave_13&quot; ## [25] &quot;matleave_wrr_95&quot; &quot;matleave_wrr_96&quot; &quot;matleave_wrr_97&quot; ## [28] &quot;matleave_wrr_98&quot; &quot;matleave_wrr_99&quot; &quot;matleave_wrr_00&quot; ## [31] &quot;matleave_wrr_01&quot; &quot;matleave_wrr_02&quot; &quot;matleave_wrr_03&quot; ## [34] &quot;matleave_wrr_04&quot; &quot;matleave_wrr_05&quot; &quot;matleave_wrr_06&quot; ## [37] &quot;matleave_wrr_07&quot; &quot;matleave_wrr_08&quot; &quot;matleave_wrr_09&quot; ## [40] &quot;matleave_wrr_10&quot; &quot;matleave_wrr_11&quot; &quot;matleave_wrr_12&quot; ## [43] &quot;matleave_wrr_13&quot; &quot;bf_dur_95&quot; &quot;bf_dur_96&quot; ## [46] &quot;bf_dur_97&quot; &quot;bf_dur_98&quot; &quot;bf_dur_99&quot; ## [49] &quot;bf_dur_00&quot; &quot;bf_dur_01&quot; &quot;bf_dur_02&quot; ## [52] &quot;bf_dur_03&quot; &quot;bf_dur_04&quot; &quot;bf_dur_05&quot; ## [55] &quot;bf_dur_06&quot; &quot;bf_dur_07&quot; &quot;bf_dur_08&quot; ## [58] &quot;bf_dur_09&quot; &quot;bf_dur_10&quot; &quot;bf_dur_11&quot; ## [61] &quot;bf_dur_12&quot; &quot;bf_dur_13&quot; &quot;mat_bfeed_6mon_95&quot; ## [64] &quot;mat_bfeed_6mon_96&quot; &quot;mat_bfeed_6mon_97&quot; &quot;mat_bfeed_6mon_98&quot; ## [67] &quot;mat_bfeed_6mon_99&quot; &quot;mat_bfeed_6mon_00&quot; &quot;mat_bfeed_6mon_01&quot; ## [70] &quot;mat_bfeed_6mon_02&quot; &quot;mat_bfeed_6mon_03&quot; &quot;mat_bfeed_6mon_04&quot; ## [73] &quot;mat_bfeed_6mon_05&quot; &quot;mat_bfeed_6mon_06&quot; &quot;mat_bfeed_6mon_07&quot; ## [76] &quot;mat_bfeed_6mon_08&quot; &quot;mat_bfeed_6mon_09&quot; &quot;mat_bfeed_6mon_10&quot; ## [79] &quot;mat_bfeed_6mon_11&quot; &quot;mat_bfeed_6mon_12&quot; &quot;mat_bfeed_6mon_13&quot; ## [82] &quot;minage_fem_leg_95&quot; &quot;minage_fem_leg_96&quot; &quot;minage_fem_leg_97&quot; ## [85] &quot;minage_fem_leg_98&quot; &quot;minage_fem_leg_99&quot; &quot;minage_fem_leg_00&quot; ## [88] &quot;minage_fem_leg_01&quot; &quot;minage_fem_leg_02&quot; &quot;minage_fem_leg_03&quot; ## [91] &quot;minage_fem_leg_04&quot; &quot;minage_fem_leg_05&quot; &quot;minage_fem_leg_06&quot; ## [94] &quot;minage_fem_leg_07&quot; &quot;minage_fem_leg_08&quot; &quot;minage_fem_leg_09&quot; ## [97] &quot;minage_fem_leg_10&quot; &quot;minage_fem_leg_11&quot; &quot;minage_fem_leg_12&quot; ## [100] &quot;legal_diff_leg_95&quot; &quot;legal_diff_leg_96&quot; &quot;legal_diff_leg_97&quot; ## [103] &quot;legal_diff_leg_98&quot; &quot;legal_diff_leg_99&quot; &quot;legal_diff_leg_00&quot; ## [106] &quot;legal_diff_leg_01&quot; &quot;legal_diff_leg_02&quot; &quot;legal_diff_leg_03&quot; ## [109] &quot;legal_diff_leg_04&quot; &quot;legal_diff_leg_05&quot; &quot;legal_diff_leg_06&quot; ## [112] &quot;legal_diff_leg_07&quot; &quot;legal_diff_leg_08&quot; &quot;legal_diff_leg_09&quot; ## [115] &quot;legal_diff_leg_10&quot; &quot;legal_diff_leg_11&quot; &quot;legal_diff_leg_12&quot; ## [118] &quot;minage_fem_pc_95&quot; &quot;minage_fem_pc_96&quot; &quot;minage_fem_pc_97&quot; ## [121] &quot;minage_fem_pc_98&quot; &quot;minage_fem_pc_99&quot; &quot;minage_fem_pc_00&quot; ## [124] &quot;minage_fem_pc_01&quot; &quot;minage_fem_pc_02&quot; &quot;minage_fem_pc_03&quot; ## [127] &quot;minage_fem_pc_04&quot; &quot;minage_fem_pc_05&quot; &quot;minage_fem_pc_06&quot; ## [130] &quot;minage_fem_pc_07&quot; &quot;minage_fem_pc_08&quot; &quot;minage_fem_pc_09&quot; ## [133] &quot;minage_fem_pc_10&quot; &quot;minage_fem_pc_11&quot; &quot;minage_fem_pc_12&quot; ## [136] &quot;legal_diff_pc_95&quot; &quot;legal_diff_pc_96&quot; &quot;legal_diff_pc_97&quot; ## [139] &quot;legal_diff_pc_98&quot; &quot;legal_diff_pc_99&quot; &quot;legal_diff_pc_00&quot; ## [142] &quot;legal_diff_pc_01&quot; &quot;legal_diff_pc_02&quot; &quot;legal_diff_pc_03&quot; ## [145] &quot;legal_diff_pc_04&quot; &quot;legal_diff_pc_05&quot; &quot;legal_diff_pc_06&quot; ## [148] &quot;legal_diff_pc_07&quot; &quot;legal_diff_pc_08&quot; &quot;legal_diff_pc_09&quot; ## [151] &quot;legal_diff_pc_10&quot; &quot;legal_diff_pc_11&quot; &quot;legal_diff_pc_12&quot; ## [154] &quot;minwage_ppp_2013&quot; &quot;mw_overtime&quot; &quot;oecd&quot; 5.1.3 Select variables # Select the 3rd and 6th to 24th columns matleave &lt;- df[ , c(3, 6:24)] # Use class(), dim(), and str() to inspect the data class(matleave) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(matleave) ## [1] 197 20 str(matleave) ## tibble [197 × 20] (S3: tbl_df/tbl/data.frame) ## $ iso3 : chr [1:197] &quot;AFG&quot; &quot;ALB&quot; &quot;DZA&quot; &quot;AND&quot; ... ## $ matleave_95: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_96: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_97: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_98: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_99: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_00: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_01: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_02: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_03: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_04: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_05: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_06: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_07: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_08: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_09: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_10: num [1:197] 2 5 3 3 2 2 2 5 NA 5 ... ## $ matleave_11: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... ## $ matleave_12: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... ## $ matleave_13: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... 5.1.4 Check &amp; Replace NAs NA: Not Available v[is.na(v)] will select all NA cells 以0取代NA的資料格。避免繪圖產生錯誤 sum(is.na(matleave))的目的是檢測還有沒有NA值。如果有的話is.na()就會是TRUE，那麼加總後，如果不是0，那就代表還有NA。 # is.na() to indicate each element is NA or NOT(TRUE/FALSE) head(is.na(matleave), n=20) iso3 matleave_95 matleave_96 matleave_97 matleave_98 matleave_99 matleave_00 matleave_01 matleave_02 matleave_03 matleave_04 matleave_05 matleave_06 matleave_07 matleave_08 matleave_09 matleave_10 matleave_11 matleave_12 matleave_13 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE # Assign 0 to those NA data matleave[is.na(matleave)] &lt;- 0 # anyNA() to check if there are still NA cells. anyNA(matleave) ## [1] FALSE # sum(is.na()) to count the number of NA sum(is.na(matleave)) ## [1] 0 5.1.5 Filtering data 5.1.5.1 Filtered by the last year value # Use logical comparison to see if the last year equals to 5 # Assign matching data to var m5 m5 &lt;- matleave[matleave$&#39;matleave_13&#39;==5, ] # nrow() to count matching data nrow(m5) ## [1] 34 # Is it possible to use length() to check the data length? # matleave$&#39;matleave_13&#39; # matleave$&#39;matleave_13&#39;==5 # length(matleave$&#39;matleave_13&#39;==5) 5.1.5.2 Filtered data by the first year value # filter rows whose &#39;matleave_95&#39; is 5, and assign to var m55 m55&lt;- m5[m5$&#39;matleave_95&#39;==5,] # filter rows whose &#39;matleave_95&#39; is not 5, and assign to var m05 m05&lt;- m5[m5$&#39;matleave_95&#39;!=5,] 5.1.6 Plotting Plotting the second rows and all columns except 1st column Question 為何要unlist()？請試著執行barplot(matleave[2, -1])這個沒有unlist()的版本，看看會有什麼錯誤訊息。資料結構有何差異呢？ 嘗試用class()或str()嘗試觀察沒有unlist()版本的資料，看看資料型態和有unlist()的會有何不同？ 5.1.6.1 Plotting one line # barplot() the second row of m55 # barplot(m55[2, ]) # raise error # barplot() the second row when neglecting the first column # barplot(m55[2, -1]) # raise error # Take a look at the data type of matleave[2, ] class(matleave[2, -1]) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; class(unlist(matleave[2, -1])) ## [1] &quot;numeric&quot; # unlist() to convert a single row data.frame to a vector for barplot() barplot(unlist(m55[2, -1])) Testing # View(matleave[1]) # select the 1st variable # View(matleave[ ,1]) # select the 1st column # View(matleave[1, ]) # select the 1st row class(m55[1]) # &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; class(m55[ ,1]) # &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; class(m55[1, ]) # &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; class(m55$iso3) # character (vector) ## [1] &quot;character&quot; 5.1.6.2 More arguments (args) # barplot() the unlisted second row (neglecting the first col) barplot(unlist(m55[2, -1])) # use ?barplot to know more argument of the function. ?barplot barplot R Documentation Bar Plots Description Creates a bar plot with vertical or horizontal bars. Usage barplot(height, ...) ## Default S3 method: barplot(height, width = 1, space = NULL, names.arg = NULL, legend.text = NULL, beside = FALSE, horiz = FALSE, density = NULL, angle = 45, col = NULL, border = par(\"fg\"), main = NULL, sub = NULL, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, xpd = TRUE, log = \"\", axes = TRUE, axisnames = TRUE, cex.axis = par(\"cex.axis\"), cex.names = par(\"cex.axis\"), inside = TRUE, plot = TRUE, axis.lty = 0, offset = 0, add = FALSE, ann = !add &amp;&amp; par(\"ann\"), args.legend = NULL, ...) ## S3 method for class 'formula' barplot(formula, data, subset, na.action, horiz = FALSE, xlab = NULL, ylab = NULL, ...) Arguments height either a vector or matrix of values describing the bars which make up the plot. If height is a vector, the plot consists of a sequence of rectangular bars with heights given by the values in the vector. If height is a matrix and beside is FALSE then each bar of the plot corresponds to a column of height, with the values in the column giving the heights of stacked sub-bars making up the bar. If height is a matrix and beside is TRUE, then the values in each column are juxtaposed rather than stacked. width optional vector of bar widths. Re-cycled to length the number of bars drawn. Specifying a single value will have no visible effect unless xlim is specified. space the amount of space (as a fraction of the average bar width) left before each bar. May be given as a single number or one number per bar. If height is a matrix and beside is TRUE, space may be specified by two numbers, where the first is the space between bars in the same group, and the second the space between the groups. If not given explicitly, it defaults to c(0,1) if height is a matrix and beside is TRUE, and to 0.2 otherwise. names.arg a vector of names to be plotted below each bar or group of bars. If this argument is omitted, then the names are taken from the names attribute of height if this is a vector, or the column names if it is a matrix. legend.text a vector of text used to construct a legend for the plot, or a logical indicating whether a legend should be included. This is only useful when height is a matrix. In that case given legend labels should correspond to the rows of height; if legend.text is true, the row names of height will be used as labels if they are non-null. beside a logical value. If FALSE, the columns of height are portrayed as stacked bars, and if TRUE the columns are portrayed as juxtaposed bars. horiz a logical value. If FALSE, the bars are drawn vertically with the first bar to the left. If TRUE, the bars are drawn horizontally with the first at the bottom. density a vector giving the density of shading lines, in lines per inch, for the bars or bar components. The default value of NULL means that no shading lines are drawn. Non-positive values of density also inhibit the drawing of shading lines. angle the slope of shading lines, given as an angle in degrees (counter-clockwise), for the bars or bar components. col a vector of colors for the bars or bar components. By default, “grey” is used if height is a vector, and a gamma-corrected grey palette if height is a matrix; see grey.colors. border the color to be used for the border of the bars. Use border = NA to omit borders. If there are shading lines, border = TRUE means use the same colour for the border as for the shading lines. main,sub main title and subtitle for the plot. xlab a label for the x axis. ylab a label for the y axis. xlim limits for the x axis. ylim limits for the y axis. xpd logical. Should bars be allowed to go outside region? log string specifying if axis scales should be logarithmic; see plot.default. axes logical. If TRUE, a vertical (or horizontal, if horiz is true) axis is drawn. axisnames logical. If TRUE, and if there are names.arg (see above), the other axis is drawn (with lty = 0) and labeled. cex.axis expansion factor for numeric axis labels (see par(‘cex’)). cex.names expansion factor for axis names (bar labels). inside logical. If TRUE, the lines which divide adjacent (non-stacked!) bars will be drawn. Only applies when space = 0 (which it partly is when beside = TRUE). plot logical. If FALSE, nothing is plotted. axis.lty the graphics parameter lty (see par(‘lty’)) applied to the axis and tick marks of the categorical (default horizontal) axis. Note that by default the axis is suppressed. offset a vector indicating how much the bars should be shifted relative to the x axis. add logical specifying if bars should be added to an already existing plot; defaults to FALSE. ann logical specifying if the default annotation (main, sub, xlab, ylab) should appear on the plot, see title. args.legend list of additional arguments to pass to legend(); names of the list are used as argument names. Only used if legend.text is supplied. formula a formula where the y variables are numeric data to plot against the categorical x variables. The formula can have one of three forms: y ~ x y ~ x1 + x2 cbind(y1, y2) ~ x (see the examples). data a data frame (or list) from which the variables in formula should be taken. subset an optional vector specifying a subset of observations to be used. na.action a function which indicates what should happen when the data contain NA values. The default is to ignore missing values in the given variables. … arguments to be passed to/from other methods. For the default method these can include further arguments (such as axes, asp and main) and graphical parameters (see par) which are passed to plot.window(), title() and axis. Value A numeric vector (or matrix, when beside = TRUE), say mp, giving the coordinates of all the bar midpoints drawn, useful for adding to the graph. If beside is true, use colMeans(mp) for the midpoints of each group of bars, see example. Author(s) R Core, with a contribution by Arni Magnusson. References Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. Murrell, P. (2005) R Graphics. Chapman &amp; Hall/CRC Press. See Also plot(…, type = “h”), dotchart; hist for bars of a continuous variable. mosaicplot(), more sophisticated to visualize several categorical variables. Examples # Formula method barplot(GNP ~ Year, data = longley) barplot(cbind(Employed, Unemployed) ~ Year, data = longley) ## 3rd form of formula - 2 categories : op &lt;- par(mfrow = 2:1, mgp = c(3,1,0)/2, mar = .1+c(3,3:1)) summary(d.Titanic &lt;- as.data.frame(Titanic)) barplot(Freq ~ Class + Survived, data = d.Titanic, subset = Age == \"Adult\" &amp; Sex == \"Male\", main = \"barplot(Freq ~ Class + Survived, *)\", ylab = \"# {passengers}\", legend.text = TRUE) # Corresponding table : (xt &lt;- xtabs(Freq ~ Survived + Class + Sex, d.Titanic, subset = Age==\"Adult\")) # Alternatively, a mosaic plot : mosaicplot(xt[,,\"Male\"], main = \"mosaicplot(Freq ~ Class + Survived, *)\", color=TRUE) par(op) # Default method require(grDevices) # for colours tN &lt;- table(Ni &lt;- stats::rpois(100, lambda = 5)) r &lt;- barplot(tN, col = rainbow(20)) #- type = \"h\" plotting *is* 'bar'plot lines(r, tN, type = \"h\", col = \"red\", lwd = 2) barplot(tN, space = 1.5, axisnames = FALSE, sub = \"barplot(..., space= 1.5, axisnames = FALSE)\") barplot(VADeaths, plot = FALSE) barplot(VADeaths, plot = FALSE, beside = TRUE) mp &lt;- barplot(VADeaths) # default tot &lt;- colMeans(VADeaths) text(mp, tot + 3, format(tot), xpd = TRUE, col = \"blue\") barplot(VADeaths, beside = TRUE, col = c(\"lightblue\", \"mistyrose\", \"lightcyan\", \"lavender\", \"cornsilk\"), legend.text = rownames(VADeaths), ylim = c(0, 100)) title(main = \"Death Rates in Virginia\", font.main = 4) hh &lt;- t(VADeaths)[, 5:1] mybarcol &lt;- \"gray20\" mp &lt;- barplot(hh, beside = TRUE, col = c(\"lightblue\", \"mistyrose\", \"lightcyan\", \"lavender\"), legend.text = colnames(VADeaths), ylim = c(0,100), main = \"Death Rates in Virginia\", font.main = 4, sub = \"Faked upper 2*sigma error bars\", col.sub = mybarcol, cex.names = 1.5) segments(mp, hh, mp, hh + 2*sqrt(1000*hh/100), col = mybarcol, lwd = 1.5) stopifnot(dim(mp) == dim(hh)) # corresponding matrices mtext(side = 1, at = colMeans(mp), line = -2, text = paste(\"Mean\", formatC(colMeans(hh))), col = \"red\") # Bar shading example barplot(VADeaths, angle = 15+10*1:5, density = 20, col = \"black\", legend.text = rownames(VADeaths)) title(main = list(\"Death Rates in Virginia\", font = 4)) # Border color barplot(VADeaths, border = \"dark blue\") # Log scales (not much sense here) barplot(tN, col = heat.colors(12), log = \"y\") barplot(tN, col = gray.colors(20), log = \"xy\") # Legend location barplot(height = cbind(x = c(465, 91) / 465 * 100, y = c(840, 200) / 840 * 100, z = c(37, 17) / 37 * 100), beside = FALSE, width = c(465, 840, 37), col = c(1, 2), legend.text = c(\"A\", \"B\"), args.legend = list(x = \"topleft\")) # Add arguments ylim, space, border, and axat/yaxt one by one to barplot() barplot(unlist(m55[2, -1]), ylim=c(0, 5)) barplot(unlist(m55[2, -1]), ylim=c(0, 5), space=0) barplot(unlist(m55[2, -1]), ylim=c(0, 5), space=0, border=NA) barplot(unlist(m55[2, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) 5.1.6.3 Plotting multiple lines 底下可以看見每一行非常相似且一致的特徵，僅有matleave內的索引由1被列出至6。因此，最好的方法是用迴圈（for-loop）的方式將相同的程式碼，從1~6之間做六次。 # plot the first row barplot(unlist(m55[1, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) # plot the second to 6th rows barplot(unlist(m55[2, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) barplot(unlist(m55[3, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) barplot(unlist(m55[4, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) barplot(unlist(m55[5, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) barplot(unlist(m55[6, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) 5.1.6.4 for-loop to plot multiple lines # use for loop and use i as index to barplot multiple subgraphs for(i in 1:6){ barplot(unlist(m55[i, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) } 5.1.6.5 Sub-plots Check ?par to get paremeters of plotting **mai**: A numerical vector of the form c(bottom, left, top, right) which gives the margin size specified in inches. **mfcol, mfrow**:A vector of the form c(nr, nc). Subsequent figures will be drawn in an nr-by-nc array on the device by columns (mfcol), or rows (mfrow), respectively. # use ?par to get more plotting parameters ?par par R Documentation Set or Query Graphical Parameters Description par can be used to set or query graphical parameters. Parameters can be set by specifying them as arguments to par in tag = value form, or by passing them as a list of tagged values. Usage par(..., no.readonly = FALSE) &lt;highlevel plot&gt; (...., &lt;tag&gt; = &lt;value&gt;) Arguments … arguments in tag = value form, a single list of tagged values, or character vectors of parameter names. Supported parameters are described in the ‘Graphical Parameters’ section. no.readonly logical; if TRUE and there are no other arguments, only parameters are returned which can be set by a subsequent par() call on the same device. Details Each device has its own set of graphical parameters. If the current device is the null device, par will open a new device before querying/setting parameters. (What device is controlled by options(“device”).) Parameters are queried by giving one or more character vectors of parameter names to par. par() (no arguments) or par(no.readonly = TRUE) is used to get all the graphical parameters (as a named list). Their names are currently taken from the unexported variable graphics:::.Pars. R.O. indicates read-only arguments: These may only be used in queries and cannot be set. (“cin”, “cra”, “csi”, “cxy”, “din” and “page” are always read-only.) Several parameters can only be set by a call to par(): “ask”, “fig”, “fin”, “lheight”, “mai”, “mar”, “mex”, “mfcol”, “mfrow”, “mfg”, “new”, “oma”, “omd”, “omi”, “pin”, “plt”, “ps”, “pty”, “usr”, “xlog”, “ylog”, “ylbias” The remaining parameters can also be set as arguments (often via …) to high-level plot functions such as plot.default, plot.window, points, lines, abline, axis, title, text, mtext, segments, symbols, arrows, polygon, rect, box, contour, filled.contour and image. Such settings will be active during the execution of the function, only. However, see the comments on bg, cex, col, lty, lwd and pch which may be taken as arguments to certain plot functions rather than as graphical parameters. The meaning of ‘character size’ is not well-defined: this is set up for the device taking pointsize into account but often not the actual font family in use. Internally the corresponding pars (cra, cin, cxy and csi) are used only to set the inter-line spacing used to convert mar and oma to physical margins. (The same inter-line spacing multiplied by lheight is used for multi-line strings in text and strheight.) Note that graphical parameters are suggestions: plotting functions and devices need not make use of them (and this is particularly true of non-default methods for e.g. plot). Value When parameters are set, their previous values are returned in an invisible named list. Such a list can be passed as an argument to par to restore the parameter values. Use par(no.readonly = TRUE) for the full list of parameters that can be restored. However, restoring all of these is not wise: see the ‘Note’ section. When just one parameter is queried, the value of that parameter is returned as (atomic) vector. When two or more parameters are queried, their values are returned in a list, with the list names giving the parameters. Note the inconsistency: setting one parameter returns a list, but querying one parameter returns a vector. Graphical Parameters adj The value of adj determines the way in which text strings are justified in text, mtext and title. A value of 0 produces left-justified text, 0.5 (the default) centered text and 1 right-justified text. (Any value in [0, 1] is allowed, and on most devices values outside that interval will also work.) Note that the adj argument of text also allows adj = c(x, y) for different adjustment in x- and y- directions. Note that whereas for text it refers to positioning of text about a point, for mtext and title it controls placement within the plot or device region. ann If set to FALSE, high-level plotting functions calling plot.default do not annotate the plots they produce with axis titles and overall titles. The default is to do annotation. ask logical. If TRUE (and the R session is interactive) the user is asked for input, before a new figure is drawn. As this applies to the device, it also affects output by packages grid and lattice. It can be set even on non-screen devices but may have no effect there. This not really a graphics parameter, and its use is deprecated in favour of devAskNewPage. bg The color to be used for the background of the device region. When called from par() it also sets new = FALSE. See section ‘Color Specification’ for suitable values. For many devices the initial value is set from the bg argument of the device, and for the rest it is normally “white”. Note that some graphics functions such as plot.default and points have an argument of this name with a different meaning. bty A character string which determined the type of box which is drawn about plots. If bty is one of “o” (the default), “l”, “7”, “c”, “u”, or “]” the resulting box resembles the corresponding upper case letter. A value of “n” suppresses the box. cex A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. This starts as 1 when a device is opened, and is reset when the layout is changed, e.g. by setting mfrow. Note that some graphics functions such as plot.default have an argument of this name which multiplies this graphical parameter, and some functions such as points and text accept a vector of values which are recycled. cex.axis The magnification to be used for axis annotation relative to the current setting of cex. cex.lab The magnification to be used for x and y labels relative to the current setting of cex. cex.main The magnification to be used for main titles relative to the current setting of cex. cex.sub The magnification to be used for sub-titles relative to the current setting of cex. cin R.O.; character size (width, height) in inches. These are the same measurements as cra, expressed in different units. col A specification for the default plotting color. See section ‘Color Specification’. Some functions such as lines and text accept a vector of values which are recycled and may be interpreted slightly differently. col.axis The color to be used for axis annotation. Defaults to “black”. col.lab The color to be used for x and y labels. Defaults to “black”. col.main The color to be used for plot main titles. Defaults to “black”. col.sub The color to be used for plot sub-titles. Defaults to “black”. cra R.O.; size of default character (width, height) in ‘rasters’ (pixels). Some devices have no concept of pixels and so assume an arbitrary pixel size, usually 1/72 inch. These are the same measurements as cin, expressed in different units. crt A numerical value specifying (in degrees) how single characters should be rotated. It is unwise to expect values other than multiples of 90 to work. Compare with srt which does string rotation. csi R.O.; height of (default-sized) characters in inches. The same as par(“cin”)[2]. cxy R.O.; size of default character (width, height) in user coordinate units. par(“cxy”) is par(“cin”)/par(“pin”) scaled to user coordinates. Note that c(strwidth(ch), strheight(ch)) for a given string ch is usually much more precise. din R.O.; the device dimensions, (width, height), in inches. See also dev.size, which is updated immediately when an on-screen device windows is re-sized. err (Unimplemented; R is silent when points outside the plot region are not plotted.) The degree of error reporting desired. family The name of a font family for drawing text. The maximum allowed length is 200 bytes. This name gets mapped by each graphics device to a device-specific font description. The default value is ““ which means that the default device fonts will be used (and what those are should be listed on the help page for the device). Standard values are ”serif”, “sans” and “mono”, and the Hershey font families are also available. (Devices may define others, and some devices will ignore this setting completely. Names starting with “Hershey” are treated specially and should only be used for the built-in Hershey font families.) This can be specified inline for text. fg The color to be used for the foreground of plots. This is the default color used for things like axes and boxes around plots. When called from par() this also sets parameter col to the same value. See section ‘Color Specification’. A few devices have an argument to set the initial value, which is otherwise “black”. fig A numerical vector of the form c(x1, x2, y1, y2) which gives the (NDC) coordinates of the figure region in the display region of the device. If you set this, unlike S, you start a new plot, so to add to an existing plot use new = TRUE as well. fin The figure region dimensions, (width, height), in inches. If you set this, unlike S, you start a new plot. font An integer which specifies which font to use for text. If possible, device drivers arrange so that 1 corresponds to plain text (the default), 2 to bold face, 3 to italic and 4 to bold italic. Also, font 5 is expected to be the symbol font, in Adobe symbol encoding. On some devices font families can be selected by family to choose different sets of 5 fonts. font.axis The font to be used for axis annotation. font.lab The font to be used for x and y labels. font.main The font to be used for plot main titles. font.sub The font to be used for plot sub-titles. lab A numerical vector of the form c(x, y, len) which modifies the default way that axes are annotated. The values of x and y give the (approximate) number of tickmarks on the x and y axes and len specifies the label length. The default is c(5, 5, 7). len is unimplemented in R. las numeric in {0,1,2,3}; the style of axis labels. 0: always parallel to the axis [default], 1: always horizontal, 2: always perpendicular to the axis, 3: always vertical. Also supported by mtext. Note that string/character rotation via argument srt to par does not affect the axis labels. lend The line end style. This can be specified as an integer or string: 0 and “round” mean rounded line caps [default]; 1 and “butt” mean butt line caps; 2 and “square” mean square line caps. lheight The line height multiplier. The height of a line of text (used to vertically space multi-line text) is found by multiplying the character height both by the current character expansion and by the line height multiplier. Default value is 1. Used in text and strheight. ljoin The line join style. This can be specified as an integer or string: 0 and “round” mean rounded line joins [default]; 1 and “mitre” mean mitred line joins; 2 and “bevel” mean bevelled line joins. lmitre The line mitre limit. This controls when mitred line joins are automatically converted into bevelled line joins. The value must be larger than 1 and the default is 10. Not all devices will honour this setting. lty The line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings “blank”, “solid”, “dashed”, “dotted”, “dotdash”, “longdash”, or “twodash”, where “blank” uses ‘invisible lines’ (i.e., does not draw them). Alternatively, a string of up to 8 characters (from c(1:9, “A”:“F”)) may be given, giving the length of line segments which are alternatively drawn and skipped. See section ‘Line Type Specification’. Functions such as lines and segments accept a vector of values which are recycled. lwd The line width, a positive number, defaulting to 1. The interpretation is device-specific, and some devices do not implement line widths less than one. (See the help on the device for details of the interpretation.) Functions such as lines and segments accept a vector of values which are recycled: in such uses lines corresponding to values NA or NaN are omitted. The interpretation of 0 is device-specific. mai A numerical vector of the form c(bottom, left, top, right) which gives the margin size specified in inches. mar A numerical vector of the form c(bottom, left, top, right) which gives the number of lines of margin to be specified on the four sides of the plot. The default is c(5, 4, 4, 2) + 0.1. mex mex is a character size expansion factor which is used to describe coordinates in the margins of plots. Note that this does not change the font size, rather specifies the size of font (as a multiple of csi) used to convert between mar and mai, and between oma and omi. This starts as 1 when the device is opened, and is reset when the layout is changed (alongside resetting cex). mfcol, mfrow A vector of the form c(nr, nc). Subsequent figures will be drawn in an nr-by-nc array on the device by columns (mfcol), or rows (mfrow), respectively. In a layout with exactly two rows and columns the base value of “cex” is reduced by a factor of 0.83: if there are three or more of either rows or columns, the reduction factor is 0.66. Setting a layout resets the base value of cex and that of mex to 1. If either of these is queried it will give the current layout, so querying cannot tell you the order in which the array will be filled. Consider the alternatives, layout and split.screen. mfg A numerical vector of the form c(i, j) where i and j indicate which figure in an array of figures is to be drawn next (if setting) or is being drawn (if enquiring). The array must already have been set by mfcol or mfrow. For compatibility with S, the form c(i, j, nr, nc) is also accepted, when nr and nc should be the current number of rows and number of columns. Mismatches will be ignored, with a warning. mgp The margin line (in mex units) for the axis title, axis labels and axis line. Note that mgp[1] affects title whereas mgp[2:3] affect axis. The default is c(3, 1, 0). mkh The height in inches of symbols to be drawn when the value of pch is an integer. Completely ignored in R. new logical, defaulting to FALSE. If set to TRUE, the next high-level plotting command (actually plot.new) should not clean the frame before drawing as if it were on a new device. It is an error (ignored with a warning) to try to use new = TRUE on a device that does not currently contain a high-level plot. oma A vector of the form c(bottom, left, top, right) giving the size of the outer margins in lines of text. omd A vector of the form c(x1, x2, y1, y2) giving the region inside outer margins in NDC (= normalized device coordinates), i.e., as a fraction (in [0, 1]) of the device region. omi A vector of the form c(bottom, left, top, right) giving the size of the outer margins in inches. page R.O.; A boolean value indicating whether the next call to plot.new is going to start a new page. This value may be FALSE if there are multiple figures on the page. pch Either an integer specifying a symbol or a single character to be used as the default in plotting points. See points for possible values and their interpretation. Note that only integers and single-character strings can be set as a graphics parameter (and not NA nor NULL). Some functions such as points accept a vector of values which are recycled. pin The current plot dimensions, (width, height), in inches. plt A vector of the form c(x1, x2, y1, y2) giving the coordinates of the plot region as fractions of the current figure region. ps integer; the point size of text (but not symbols). Unlike the pointsize argument of most devices, this does not change the relationship between mar and mai (nor oma and omi). What is meant by ‘point size’ is device-specific, but most devices mean a multiple of 1bp, that is 1/72 of an inch. pty A character specifying the type of plot region to be used; “s” generates a square plotting region and “m” generates the maximal plotting region. smo (Unimplemented) a value which indicates how smooth circles and circular arcs should be. srt The string rotation in degrees. See the comment about crt. Only supported by text. tck The length of tick marks as a fraction of the smaller of the width or height of the plotting region. If tck &gt;= 0.5 it is interpreted as a fraction of the relevant side, so if tck = 1 grid lines are drawn. The default setting (tck = NA) is to use tcl = -0.5. tcl The length of tick marks as a fraction of the height of a line of text. The default value is -0.5; setting tcl = NA sets tck = -0.01 which is S’ default. usr A vector of the form c(x1, x2, y1, y2) giving the extremes of the user coordinates of the plotting region. When a logarithmic scale is in use (i.e., par(“xlog”) is true, see below), then the x-limits will be 10 ^ par(“usr”)[1:2]. Similarly for the y-axis. xaxp A vector of the form c(x1, x2, n) giving the coordinates of the extreme tick marks and the number of intervals between tick-marks when par(“xlog”) is false. Otherwise, when log coordinates are active, the three values have a different meaning: For a small range, n is negative, and the ticks are as in the linear case, otherwise, n is in 1:3, specifying a case number, and x1 and x2 are the lowest and highest power of 10 inside the user coordinates, 10 ^ par(“usr”)[1:2]. (The “usr” coordinates are log10-transformed here!) n = 1 will produce tick marks at 10^j for integer j, n = 2 gives marks k 10^j with k {1, 5}, n = 3 gives marks k 10^j with k {1, 2, 5}. See axTicks() for a pure R implementation of this. This parameter is reset when a user coordinate system is set up, for example by starting a new page or by calling plot.window or setting par(“usr”): n is taken from par(“lab”). It affects the default behaviour of subsequent calls to axis for sides 1 or 3. It is only relevant to default numeric axis systems, and not for example to dates. xaxs The style of axis interval calculation to be used for the x-axis. Possible values are “r”, “i”, “e”, “s”, “d”. The styles are generally controlled by the range of data or xlim, if given. Style “r” (regular) first extends the data range by 4 percent at each end and then finds an axis with pretty labels that fits within the extended range. Style “i” (internal) just finds an axis with pretty labels that fits within the original data range. Style “s” (standard) finds an axis with pretty labels within which the original data range fits. Style “e” (extended) is like style “s”, except that it is also ensures that there is room for plotting symbols within the bounding box. Style “d” (direct) specifies that the current axis should be used on subsequent plots. (Only “r” and “i” styles have been implemented in R.) xaxt A character which specifies the x axis type. Specifying “n” suppresses plotting of the axis. The standard value is “s”: for compatibility with S values “l” and “t” are accepted but are equivalent to “s”: any value other than “n” implies plotting. xlog A logical value (see log in plot.default). If TRUE, a logarithmic scale is in use (e.g., after plot(*, log = “x”)). For a new device, it defaults to FALSE, i.e., linear scale. xpd A logical value or NA. If FALSE, all plotting is clipped to the plot region, if TRUE, all plotting is clipped to the figure region, and if NA, all plotting is clipped to the device region. See also clip. yaxp A vector of the form c(y1, y2, n) giving the coordinates of the extreme tick marks and the number of intervals between tick-marks unless for log coordinates, see xaxp above. yaxs The style of axis interval calculation to be used for the y-axis. See xaxs above. yaxt A character which specifies the y axis type. Specifying “n” suppresses plotting. ylbias A positive real value used in the positioning of text in the margins by axis and mtext. The default is in principle device-specific, but currently 0.2 for all of R’s own devices. Set this to 0.2 for compatibility with R &lt; 2.14.0 on x11 and windows() devices. ylog A logical value; see xlog above. Color Specification Colors can be specified in several different ways. The simplest way is with a character string giving the color name (e.g., “red”). A list of the possible colors can be obtained with the function colors. Alternatively, colors can be specified directly in terms of their RGB components with a string of the form “#RRGGBB” where each of the pairs RR, GG, BB consist of two hexadecimal digits giving a value in the range 00 to FF. Colors can also be specified by giving an index into a small table of colors, the palette: indices wrap round so with the default palette of size 8, 10 is the same as 2. This provides compatibility with S. Index 0 corresponds to the background color. Note that the palette (apart from 0 which is per-device) is a per-session setting. Negative integer colours are errors. Additionally, “transparent” is transparent, useful for filled areas (such as the background!), and just invisible for things like lines or text. In most circumstances (integer) NA is equivalent to “transparent” (but not for text and mtext). Semi-transparent colors are available for use on devices that support them. The functions rgb, hsv, hcl, gray and rainbow provide additional ways of generating colors. Line Type Specification Line types can either be specified by giving an index into a small built-in table of line types (1 = solid, 2 = dashed, etc, see lty above) or directly as the lengths of on/off stretches of line. This is done with a string of an even number (up to eight) of characters, namely non-zero (hexadecimal) digits which give the lengths in consecutive positions in the string. For example, the string “33” specifies three units on followed by three off and “3313” specifies three units on followed by three off followed by one on and finally three off. The ‘units’ here are (on most devices) proportional to lwd, and with lwd = 1 are in pixels or points or 1/96 inch. The five standard dash-dot line types (lty = 2:6) correspond to c(“44”, “13”, “1343”, “73”, “2262”). Note that NA is not a valid value for lty. Note The effect of restoring all the (settable) graphics parameters as in the examples is hard to predict if the device has been resized. Several of them are attempting to set the same things in different ways, and those last in the alphabet will win. In particular, the settings of mai, mar, pin, plt and pty interact, as do the outer margin settings, the figure layout and figure region size. References Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. Murrell, P. (2005) R Graphics. Chapman &amp; Hall/CRC Press. See Also plot.default for some high-level plotting parameters; colors; clip; options for other setup parameters; graphic devices x11, postscript and setting up device regions by layout and split.screen. Examples op &lt;- par(mfrow = c(2, 2), # 2 x 2 pictures on one plot pty = \"s\") # square plotting region, # independent of device size ## At end of plotting, reset to previous settings: par(op) ## Alternatively, op &lt;- par(no.readonly = TRUE) # the whole list of settable par's. ## do lots of plotting and par(.) calls, then reset: par(op) ## Note this is not in general good practice par(\"ylog\") # FALSE plot(1 : 12, log = \"y\") par(\"ylog\") # TRUE plot(1:2, xaxs = \"i\") # 'inner axis' w/o extra space par(c(\"usr\", \"xaxp\")) ( nr.prof &lt;- c(prof.pilots = 16, lawyers = 11, farmers = 10, salesmen = 9, physicians = 9, mechanics = 6, policemen = 6, managers = 6, engineers = 5, teachers = 4, housewives = 3, students = 3, armed.forces = 1)) par(las = 3) barplot(rbind(nr.prof)) # R 0.63.2: shows alignment problem par(las = 0) # reset to default require(grDevices) # for gray ## 'fg' use: plot(1:12, type = \"b\", main = \"'fg' : axes, ticks and box in gray\", fg = gray(0.7), bty = \"7\" , sub = R.version.string) ex &lt;- function() { old.par &lt;- par(no.readonly = TRUE) # all par settings which # could be changed. on.exit(par(old.par)) ## ... ## ... do lots of par() settings and plots ## ... invisible() #-- now, par(old.par) will be executed } ex() ## Line types showLty &lt;- function(ltys, xoff = 0, ...) { stopifnot((n &lt;- length(ltys)) &gt;= 1) op &lt;- par(mar = rep(.5,4)); on.exit(par(op)) plot(0:1, 0:1, type = \"n\", axes = FALSE, ann = FALSE) y &lt;- (n:1)/(n+1) clty &lt;- as.character(ltys) mytext &lt;- function(x, y, txt) text(x, y, txt, adj = c(0, -.3), cex = 0.8, ...) abline(h = y, lty = ltys, ...); mytext(xoff, y, clty) y &lt;- y - 1/(3*(n+1)) abline(h = y, lty = ltys, lwd = 2, ...) mytext(1/8+xoff, y, paste(clty,\" lwd = 2\")) } showLty(c(\"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\")) par(new = TRUE) # the same: showLty(c(\"solid\", \"44\", \"13\", \"1343\", \"73\", \"2262\"), xoff = .2, col = 2) showLty(c(\"11\", \"22\", \"33\", \"44\", \"12\", \"13\", \"14\", \"21\", \"31\")) # use par() to set-up the layout of subgraphs # use the parameter main=c(0.2, 0.2, 0.2, 0.2) to thrink the padding of figures. par(mfrow=c(3,2), mai= c(0.2, 0.2, 0.2, 0.2)) for(i in 1:6){ barplot(unlist(m55[i, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) } # plot more rows to see what happens par(mfrow=c(3,2), mai= c(0.2, 0.2, 0.2, 0.2)) for(i in 1:10){ barplot(unlist(m55[i, -1]), ylim=c(0, 5), space=0, border=NA, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;) } # plot all subplots in a figure # nrow() to check number of row of m55. nrow(m55) ## [1] 18 # use par() to set-up plotting parameters. par(mfrow=c(4, 6), mai= c(0.2, 0.2, 0.2, 0.2)) # use for-loop to plot all graph as subgraph for (i in 1:nrow(m55)){ barplot(unlist(m55[i, -1]), border=NA, space=0, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim = c(0,5)) } par(mfrow=c(4,6), mai= c(0.2, 0.2, 0.2, 0.2)) for (i in 1:nrow(m55)){ barplot(unlist(m55[i, -1]), border=NA, space=0,xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim = c(0,5)) title(m55[i,1], line = -4, cex.main=3) } 5.1.7 Practice02_1_1 Plotting more # plotting matleave_95 != 5 but matleve_13 == 5 # plotting for matleave_13 == 4 5.1.8 Practice02_2_2 selecting and filtering by dplyr I df &lt;- read_excel(&quot;data/WORLD-MACHE_Gender_6.8.15.xls&quot;, &quot;Sheet1&quot;, col_names=T) # select columns by index # matleave &lt;- df[ , c(3, 6:24)] # select all NA cells and assign 0 to them # matleave[is.na(matleave)] &lt;- 0 # filter rows by condition # m5 &lt;- matleave[matleave$&#39;matleave_13&#39; == 5, ] # filter rows by condition # m55&lt;- m5[m5$&#39;matleave_95&#39; == 5,] # plot par(mfrow=c(4,6), mai= c(0.2, 0.2, 0.2, 0.2)) for (i in c(1:nrow(m55))){ barplot(unlist(m55[i,-1]), border=NA, space=0,xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim = c(0,5)) title(m55[i,1], line = -4, cex.main=3) } 5.1.9 (More) Clean version # readxl::read_excel() to import the xls file df &lt;- read_excel(&quot;data/WORLD-MACHE_Gender_6.8.15.xls&quot;, &quot;Sheet1&quot;, col_names=T) # select iso3, and matleave columns by index matleave &lt;- df[ , c(3, 6:24)] # str() to inspect the data structure of str(matleave) ## tibble [197 × 20] (S3: tbl_df/tbl/data.frame) ## $ iso3 : chr [1:197] &quot;AFG&quot; &quot;ALB&quot; &quot;DZA&quot; &quot;AND&quot; ... ## $ matleave_95: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_96: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_97: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_98: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_99: num [1:197] 2 5 3 2 2 2 2 3 1 5 ... ## $ matleave_00: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_01: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_02: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_03: num [1:197] 2 5 3 3 2 2 2 3 1 5 ... ## $ matleave_04: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_05: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_06: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_07: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_08: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_09: num [1:197] 2 5 3 3 2 2 2 5 1 5 ... ## $ matleave_10: num [1:197] 2 5 3 3 2 2 2 5 NA 5 ... ## $ matleave_11: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... ## $ matleave_12: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... ## $ matleave_13: num [1:197] 2 5 3 3 2 2 2 5 3 5 ... # select all NA cells and assign 0 to them matleave[is.na(matleave)] &lt;- 0 # filter rows by condition m5 &lt;- matleave[matleave$&#39;matleave_13&#39; == 5, ] # filter rows by condition m55&lt;- m5[m5$&#39;matleave_95&#39; == 5,] # plot par(mfrow=c(4,6), mai= c(0.2, 0.2, 0.2, 0.2)) for (i in c(1:nrow(m55))){ barplot(unlist(m55[i,-1]), border=NA, space=0,xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim = c(0,5)) title(m55[i,1], line = -4, cex.main=3) } library(tidyverse) options(stringsAsFactors = F) options(scipen = 999) library(readxl) read_excel(&quot;data/WORLD-MACHE_Gender_6.8.15.xls&quot;, &quot;Sheet1&quot;, col_names=T) %&gt;% select(iso3, 6:24) %&gt;% filter(matleave_13 == 5, matleave_95 == 5) %&gt;% gather(&quot;year&quot;, &quot;degree&quot;, 2:20) %&gt;% # spread(year, degree, fill = 0) %&gt;% View replace_na(list(degree = 0)) %&gt;% mutate(year2 = as.POSIXct(strptime(year, &quot;matleave_%y&quot;))) %&gt;% mutate(year3 = lubridate::year(year2)) %&gt;% ggplot() + aes(year3, degree) + geom_col(color = &quot;royalblue&quot;, fill = &quot;royalblue&quot;) + facet_wrap(~ iso3) + theme_void() 5.1.10 (More) The fittest version to compute staySame # staySame version # staySame &lt;- apply(m5[,2:20], 1, function(x) length(unique(x[!is.na(x)]))) # m55 &lt;- m5[staySame, ] # m50 &lt;- m5[!staySame, ] 5.2 計數與樞紐：台北住宅竊盜點位 觀察值、點位資料：公部門所發布的開放資料通常會根據某些類別進行統計，例如年齡、性別、教育程度、地區等等，只有少部分的資料會用觀察值（Observation）的方式來記錄，也就是每一個案例紀錄一筆資料。例如疫情一開始人數還少的時候，會逐一記錄每個個案；地理資訊系統上面記錄某些機構或某些特定地點的時候也是點位資料；或在觀察輿情時，每筆發言或留言都是一筆觀察值。而以下的例子「臺北市住宅竊盜點位資訊」就是逐案紀錄的點位資料，其他在臺北資料大平台的類似案例還有臺北市街頭隨機強盜案件點位資訊、臺北市街頭隨機搶奪案件點位資訊、臺北市汽車竊盜點位資訊、臺北市機車竊盜點位資訊、臺北市自行車竊盜點位資訊、臺北市道路交通事故斑點圖、臺北市娛樂營業場所噪音告發案件點位資訊、臺北市非營業用卡拉OK噪音告發案件點位資訊、臺北市營建工程噪音告發案件點位資訊等，主要為噪音、竊盜、交通事故等相關點位資料。 5.2.1 讀取檔案 規劃比較完善的開放資料平台會提供API給程式設計者存取，例如臺北資料大平台或內政部開放資料平台。但我們這邊用下載CSV（Common Separated Value）檔的方式來讀取這筆資料，以理解CSV這種檔案型態如何儲存資料。首先要至臺北資料大平台上查詢「住宅竊盜」，可以找到臺北市住宅竊盜點位資訊。將該CSV檔下載至個人本機端，置入data 資料夾中，便可以用read.csv()讀取該檔案。或可用tidyverse系列套件中的readr::read_csv()來直接讀取該網址所指到的檔案。 在Console視窗中用??read_csv()可以查詢到這些函式的用法： read.csv() to read csv and convert it to a data.frame readr::read_csv() to read csv or read a csv by an url df &lt;- read.csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;) head(df) 編號 案類 發生日期 發生時段 發生地點 1 住宅竊盜 1030623 08~10 臺北市中正區廈門街91~120號 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 4 住宅竊盜 1040101 06~08 臺北市中山區新生北路1段91~120號 5 住宅竊盜 1040101 10~12 臺北市文山區明興里興隆路4段1~30號 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 用readr::read_csv()來讀取。除了 base套件的read.csv()外，也可使用readr套件的read_csv()函式來讀取，該套件屬於tidyverse套件系的其中一個套件，如果已經有用install.packages(\"tidyverse\")安裝過，只要用library(tidyverse)就可以使用read_csv()函式。在此鼓勵各位使用tidyverse系列套件。普遍來說，read_csv() 的功能和效果都會比read.csv()好，該函式還會自動猜測每個變數的變數型態並直接進行轉換（尤其是有時間欄位的時候，會非常方便）。 除錯：萬一遇到中文檔案會有讀檔編碼問題時，有可能該檔案是用big5來儲存的，可以在read_csv()中設定locale來指定讀取的編碼方法。如read_csv(url, locale = locale(encoding = \"Big5\")) library(readr) df &lt;- read_csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;) # df &lt;- read_csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;, locale = locale(encoding = &quot;Big5&quot;)) df %&gt;% head() 編號 案類 發生日期 發生時段 發生地點 1 住宅竊盜 1030623 08~10 臺北市中正區廈門街91~120號 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 4 住宅竊盜 1040101 06~08 臺北市中山區新生北路1段91~120號 5 住宅竊盜 1040101 10~12 臺北市文山區明興里興隆路4段1~30號 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 直接依資料網址讀取檔案。現在的程式語言所設計的讀取檔案函式通常會允許使用者直接讀取資料所在的URL。所以，我們可以直接從網路上載入台北市竊盜案資料。首先要至臺北資料大平台上查詢「住宅竊盜」，可以找到臺北市住宅竊盜點位資訊，點選後對右上方的下載按右鍵可取得鏈結到該資料的URL（如https://data.taipei/api/getDatasetInfo/downloadResource?id=68785231-d6c5-47a1-b001-77eec70bec02&amp;rid=93d9bc2d-af08-4db7-a56b-9f0a49226fa3）。 由於該資料網址似非永久網址，故本範例並未執行以下程式碼，僅提供範例程式碼讓個人替換網址來做測試。 url &lt;- &quot;https://data.taipei/api/v1/dataset/93d9bc2d-af08-4db7-a56b-9f0a49226fa3?scope=resourceAquire&quot; res &lt;- read_json(url, simplifyVector = T) df &lt;- res$result$results head(df) _id _importdate 編號 案類 發生日期 發生時段 發生地點 1 2023-01-09 10:04:19.270425 1 住宅竊盜 1030623 08~10 臺北市中正區廈門街91~120號 2 2023-01-09 10:04:19.280318 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 3 2023-01-09 10:04:19.281881 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 4 2023-01-09 10:04:19.283264 4 住宅竊盜 1040101 06~08 臺北市中山區新生北路1段91~120號 5 2023-01-09 10:04:19.284529 5 住宅竊盜 1040101 10~12 臺北市文山區明興里興隆路4段1~30號 6 2023-01-09 10:04:19.285693 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 dplyr::glimpse(df) ## Rows: 20 ## Columns: 7 ## $ `_id` &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ `_importdate` &lt;df[,3]&gt; &lt;data.frame[20 x 3]&gt; ## $ 編號 &lt;chr&gt; &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;1… ## $ 案類 &lt;chr&gt; &quot;住宅竊盜&quot;, &quot;住宅竊盜&quot;, &quot;住宅竊盜&quot;, &quot;住宅竊盜&quot;, &quot;住宅竊… ## $ 發生日期 &lt;chr&gt; &quot;1030623&quot;, &quot;1040101&quot;, &quot;1040101&quot;, &quot;1040101&quot;, &quot;1040101&quot;, &quot;… ## $ 發生時段 &lt;chr&gt; &quot;08~10&quot;, &quot;00~02&quot;, &quot;00~02&quot;, &quot;06~08&quot;, &quot;10~12&quot;, &quot;00~02&quot;, &quot;0… ## $ 發生地點 &lt;chr&gt; &quot;臺北市中正區廈門街91~120號&quot;, &quot;臺北市文山區萬美里萬寧街1… # Method 2. Get the url and write to local disk # GET(url, write_disk(&quot;data/tptheft.csv&quot;, overwrite = TRUE)) (參考) 用R程式將該網址的檔案抓回本機端儲存。部分Mac電腦無法使用read.csv()從網路上取得資料又轉為data.frame，一個可行的辦法是先用GET(url,write_disk(\"data/tptheft.csv\"))將其取回並命名為data/tptheft.csv，之後再用df &lt;- read.csv(\"data/tptheft.csv\")直接讀取該檔案。 GET(url, write_disk(&quot;data/tptheft.csv&quot;, overwrite = TRUE)) df &lt;- read.csv(&quot;data/tptheft.csv&quot;) 5.2.2 查看資料內容 View(df) 用RStudio所提供的GUI直接觀看變數。自行移去#註解符號來測試，因為knit成html檔時，有View()的指令都會造成knit程序中斷。 head(df) 取前面六筆資料（也就是六列的資料來概觀該資料） class(df) 印出該 str(df) # View(df) head(df) # get first part of the data.frame class(df) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str(df) ## &#39;data.frame&#39;: 3347 obs. of 5 variables: ## $ 編號 : int 1 2 3 4 5 6 7 8 9 10 ... ## $ 案類 : chr &quot;住宅竊盜&quot; &quot;住宅竊盜&quot; &quot;住宅竊盜&quot; &quot;住宅竊盜&quot; ... ## $ 發生日期: int 1030623 1040101 1040101 1040101 1040101 1040102 1040102 1040102 1040102 1040104 ... ## $ 發生時段: chr &quot;08~10&quot; &quot;00~02&quot; &quot;00~02&quot; &quot;06~08&quot; ... ## $ 發生地點: chr &quot;臺北市中正區廈門街91~120號&quot; &quot;臺北市文山區萬美里萬寧街1~30號&quot; &quot;臺北市信義區富台里忠孝東路5段295巷6弄1~30號&quot; &quot;臺北市中山區新生北路1段91~120號&quot; ... summary(df) ## 編號 案類 發生日期 發生時段 發生地點 ## Min. : 1.0 Length:3347 Min. :1030623 Length:3347 Length:3347 ## 1st Qu.: 837.5 Class :character 1st Qu.:1050320 Class :character Class :character ## Median :1674.0 Mode :character Median :1060708 Mode :character Mode :character ## Mean :1674.0 Mean :1063954 ## 3rd Qu.:2510.5 3rd Qu.:1080306 ## Max. :3347.0 Max. :1110328 5.2.3 觀察資料維度 e.g., dim(), ncol(), nrow(),length() dim(df) ## [1] 3347 5 ncol(df) ## [1] 5 nrow(df) ## [1] 3347 length(df) ## [1] 5 5.2.4 觀察變數名稱 names(df) 列出變數名稱 df$發生地點 顯示該變數內容 df$發生時段 顯示該變數內容 length(df$發生時段) 顯示該變數的長度（相當於有幾個） 5.2.5 萃取所需新變項 該data.frame包含編號、案類、發生日期、發生時段、發生地點五個變項。其中比較有意義的應該是發生日期、發生時段和發生地點。然而，發生地點幾乎是完整地址，除非要繪製發生的地圖點位地圖，才會需要近乎完整的地址。假設我們的目標是抽取出台北市的「行政區」，發生地點的格式還蠻一致的如「臺北市中正區廈門街91~120號」。因此，我們只要抽出發生地點的第4至6個字即可。 從一個字串中抽取出第n個字到第m個字，要用substr()或stringr套件的str_sub()。可以用?substr或?str_sub查詢help中的相關用法。在此 我將中文變數現在時間的資料指給一個新的英文變項time。 從變數發生地點，用substr()取出行政區（region） 或用stringr::str_sub() ?substr查詢其用法和意義。相當於getting sub string since x to y。 # Get substring of var &quot;發生時段&quot; and assign to a new time var df$time &lt;- df$發生時段 # Get substring of var &quot;發生地點&quot; and assign to a new region var df$region &lt;- substr(df$發生地點, 4, 5) head(df) _id _importdate 編號 案類 發生日期 發生時段 發生地點 time region 1 2023-01-09 10:04:19.270425 1 住宅竊盜 1030623 08~10 臺北市中正區廈門街91~120號 08~10 中正 2 2023-01-09 10:04:19.280318 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 00~02 文山 3 2023-01-09 10:04:19.281881 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 00~02 信義 4 2023-01-09 10:04:19.283264 4 住宅竊盜 1040101 06~08 臺北市中山區新生北路1段91~120號 06~08 中山 5 2023-01-09 10:04:19.284529 5 住宅竊盜 1040101 10~12 臺北市文山區明興里興隆路4段1~30號 10~12 文山 6 2023-01-09 10:04:19.285693 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 00~02 士林 Practice. 萃取月份作為新變項month 除了時間和地區可能會有差別外，那月份會不會竊盜案的數量也有差異呢？會不會冬天小偷也都在家休息了，夏天多呢？請嘗試從發生日期萃取出竊盜案發生的月份，並儲存為一個新的變項month。 # YOUR CODE SHOULD BE HERE 5.2.6 IV. 樞紐分析：計數、加總與彙整。 Pivot analysis: Counting and Summarizing 清理完資料後，我們要回答的第一個數據問題通常是「那XXX的案例有幾個？」例如：大安區有多少竊盜案？10~12這個時段有多少案例。 5.2.7 方法一：Counting by table() table()函式可以對Vector中的值進行計數（Counting）。table(df$time) 相當於去計數不同的時間區間出現多少起案例；table(df$region) 相當於去計數不同地區各出現多少起案例。 提示：可以用class(tb_1) 觀察用table() 計數後所產生的資料型態（table）。 # counting the frequency of time variable (tb_1 &lt;- table(df$time)) 00~02 04~06 06~08 08~10 10~12 12~14 16~18 18~20 4 3 3 1 3 2 3 1 class(tb_1) ## [1] &quot;table&quot; ## table # counting the frequency of region variable table(df$region) 中山 中正 信義 北投 士林 文山 萬華 3 3 3 1 2 4 4 5.2.8 方法二：Counting by tapply() 我們也可用tapply() 函式來達到一樣的目的。Apply家族的函式都是，針對某個資料，將某個函式套用到某個物件上。tapply() 即是用來做計數的，tapply(df$編號, df$time, length)有三個輸入，第一個輸入為整體物件，第二個輸入為要據以彙整的變項，在此為df$time，第三個是要用來彙整的函式，因為這裡要做計數，所以要用length函式。 註：同樣用class()來觀察彙整後的資料型態為array，和前者的table資料型態不同。 5.2.9 V. 依照變數值篩選資料 該項竊盜案資料整理時經常不慎用不同的時間區間來標記，有時候也會不小心把新北市的資料給那進來，所以需要做資料篩選。從各個時間區間的竊盜案出現次數來觀察，有少數的案件出現在奇數的時間區間如09~11或12~15等等需要篩除；從各個行政區的竊盜案出現次數來觀察，確實都是台北市的竊盜案。 接下來要用base套件的R，根據某個變數值（例如上述的時間）來篩出符合條件的資料，或者篩去不符合條件的資料。其語法是要在df[ , ]逗號前加上篩選的條件，也就是對資料列進行篩選，篩出或篩除都是以整列為單位。在此的條件是df$time在00~02、02~04、…之間；或者是df$time不在03~05、05~07、…之間。表示法分別如下： df$time %in% c(&quot;00~02&quot;, &quot;02~04&quot;, &quot;04~6&quot;,...) !df$time %in% c(&quot;03~05&quot;, &quot;05~07&quot;, ...) %in% 表示的是左方df$time的值是否是右方Vector中的其中一個 如果要表示不包含，就在df%time加一個NOT，也就是!。 依照各組時間的案例個數統計後，篩除資料未足100的時間區間如下，最後再用table(df$time) 計算一次，發現每個時段都兩三、百個案例，且涵蓋整日的時間。清理後沒有重疊的時間區間，做類別資料分析會比較準確。 # filter out irrelevant timestamp df &lt;- df[!df$time %in% c(&quot;03~05&quot;, &quot;05~07&quot;, &quot;09~11&quot;, &quot;11~13&quot;, &quot;12~15&quot;, &quot;15~17&quot;, &quot;15~18&quot;, &quot;17~19&quot;, &quot; 18~21&quot;, &quot;19~21&quot;, &quot;21~23&quot;, &quot;21~24&quot;, &quot;23~01&quot;), ] table(df$time) 00~02 04~06 06~08 08~10 10~12 12~14 16~18 18~20 4 3 3 1 3 2 3 1 # filter out irrelevant region(area) # df &lt;- df[!df$region %in% c(&quot;三重&quot;, &quot;中和&quot;, &quot;淡水&quot;, &quot;板橋&quot;), ] 5.2.10 VI. 雙變數樞紐分析 類別變項分析通常是要考驗兩個變項間的關係，從上述的計數中，我可以看見不同行政區或者不同時間的竊盜案數量，但我進一步想知道，那不同行政區的竊盜案常發生時間是否不同？這時後就要做時間和行政區的交叉分析。我們同樣可以用table()和tapply()來做兩個變項的交叉分析，寫法如下。 5.2.10.1 (1) by table() 用table()來交叉分析的結果如下，所得到的結果之變數型態仍是table型態。 # Tabulating time and region variables (res_table &lt;- table(df$time, df$region)) 中山 中正 信義 北投 士林 文山 萬華 00~02 1 0 1 0 1 1 0 04~06 0 0 1 0 0 0 2 06~08 1 0 0 0 0 0 2 08~10 0 1 0 0 0 0 0 10~12 1 0 1 0 0 1 0 12~14 0 0 0 1 1 0 0 16~18 0 2 0 0 0 1 0 18~20 0 0 0 0 0 1 0 # Checking it class and its content class(res_table) ## [1] &quot;table&quot; ## [1] &quot;table&quot; 5.2.10.2 (2) by tapply() 用tapply()來做兩個變數交叉分析的語法如下，必須要把兩個Vector包在一個list()中。其他不變。兩個變項用tapply()交叉分析後的結果，變數型態會變成matrix。前者用table()來交叉分析的仍是table型態。 res_tapply 中山 中正 信義 北投 士林 文山 萬華 00~02 1 NA 1 NA 1 1 NA 04~06 NA NA 1 NA NA NA 2 06~08 1 NA NA NA NA NA 2 08~10 NA 1 NA NA NA NA NA 10~12 1 NA 1 NA NA 1 NA 12~14 NA NA NA 1 1 NA NA 16~18 NA 2 NA NA NA 1 NA 18~20 NA NA NA NA NA 1 NA # View(res) 5.2.10.3 (3) by dplyr::count() 這邊多介紹一個用dplyr套件的count()函式來做交叉分析的方法（未來會常用這個方法，因為dplyr是tidyverse系列套件的核心套件。dplyr的函式第一個參數永遠是該data.frame， 例如count()；後面time與region則是這個data.frame中的兩個變項。不像tapply()或table()的結果一樣，欄與列分別為time與region，count()出來的結果會有兩個變項分別是指定要計數的time與region ，且會新增一個變項n，代表這組數據（time x region）共有幾個。這種表達型態通常稱為long-table（長表）、而tapply()或table() 的結果通常稱為wide-table（寬表）為典型的交叉分析表。 目前大部分的類別資料分析還是會採用交叉分析表的型態，但未來我們要用tidyverse系列套件做大量的數據彙整或視覺化時，都會盡可能想辦法轉為Long-table型態，讓每一欄剛好就是一個變項。只要是tidyverse系列套件所計算出來的資料型態幾乎都是類似data.frame的型態，例如觀察count的結果便是\"tbl_df\" \"tbl\" \"data.frame\"。 那長表列可以轉為寬表嗎？可以，tidyverse系列套件中的tidyr套件有個函式spread()可以接著把某個變項展開為欄。例如原本上述的列是時間與行政區的交叉組合，但我可以把行政區展開為欄、或者把時間展開為欄。spread(res_count, region, n, fill = 0) 有四個參數，遵循tidyverse系列套件的規則，第一個位置為data.frame，第二個參數則是要被展開至欄的變項這裡為region，第三個參數則是因應region被展開後，那中間交叉分析的數值就是n，最後一個參數是避免spread時有些交叉組是沒有資料的，因此fill=0可以指定，如果某個time x region的交叉組別是沒資料的，就填上0，也有可能是用fill=NA填上NA。以下的例子中也提供了將time 展開至欄的寫法供參考。 展開後的資料型態和前者計數後的資料型態一樣，都是\"tbl_df\" \"tbl\" \"data.frame\"。這是為什麼tidyverse系列的套件逐漸變成R的顯學的原因之一。 library(tidyr) # spreading the region into columns (res_count_spread &lt;- spread(res_count, region, n, fill = 0)) time 中山 中正 信義 北投 士林 文山 萬華 00~02 1 0 1 0 1 1 0 04~06 0 0 1 0 0 0 2 06~08 1 0 0 0 0 0 2 08~10 0 1 0 0 0 0 0 10~12 1 0 1 0 0 1 0 12~14 0 0 0 1 1 0 0 16~18 0 2 0 0 0 1 0 18~20 0 0 0 0 0 1 0 class(res_count_spread) ## [1] &quot;data.frame&quot; # spreading the time into columns # res_count_spread &lt;- spread(res_count, time, n, fill = 0) res_count_spread time 中山 中正 信義 北投 士林 文山 萬華 00~02 1 0 1 0 1 1 0 04~06 0 0 1 0 0 0 2 06~08 1 0 0 0 0 0 2 08~10 0 1 0 0 0 0 0 10~12 1 0 1 0 0 1 0 12~14 0 0 0 1 1 0 0 16~18 0 2 0 0 0 1 0 18~20 0 0 0 0 0 1 0 # ??dplyr::count 寬表格亦可用tidyr的gather()函式轉回長表格型態： (long_table &lt;- tidyr::gather(res_count_spread, region, n, -time)) %&gt;% datatable() Practice 使用count()來計數 請練習看看如果用count()來計數單一變項，如前述的region、time或前面練習中新產生的month。 # YOUR CODE SHOULD BE HERE 5.2.11 VII. 繪圖 Plotting 通常這種類別資料交叉分析最常用的圖表型態之一便是Mosaic Plot（但事實上Mosaic Plot不見能夠被一眼就了解）。我們可以把交叉分析後的變項res_table直接用MosaicPlot來繪圖。 # mosaicplot() to plot 2-dim categorical vars. mosaicplot(res_table) # Add argument main (figure title) mosaicplot(res_table, main=&quot;mosaic plot&quot;) 5.2.11.1 (1) 無法顯示中文 大部分的視覺化套件都無法順利顯示中文，除非特別指定所要用的中文字型。這方面網路上可以找到很多的說明，但非常討厭的是，幾乎每換一套視覺化工具，換一套語言，就有不同的中文字體指定方式。例如用base的plot()來繪圖或用ggplot()的中文字型指定方法便不同，且軸上面有中文、圖標有中文、或者圖內有中文都要分開指定，非常討人厭。 Mosaic Plot屬於base R的plot()，其中文指定方法要指定在繪圖前的par()函式中（par為parameter的意思），指定方法為par(family=('Heiti TC Light'))，Heiti TC Light為字體名稱，為OSX上在用的黑體細字，STKaiti則為標楷體。然後，par()和mosaicplot()兩個函式要「同時執行」，也就是請你直接用shift-cmd(ctrl)-Enter執行整個code-cell，或者將該兩個函式選起來一次執行。 par(family=(&#39;STKaiti&#39;)) # par(family=(&#39;Heiti TC Light&#39;)) mosaicplot(res_table, main=&quot;mosaic plot&quot;, color=T) 5.2.11.2 (2) 自訂顏色 目前顏色實在過醜，你可以自訂顏色指給mosaicplot()。例如我底下便產製了12種顏色後，將其作為mosaicplot()的參數 # Set up color by yourself. colors &lt;- c(&#39;#D0104C&#39;, &#39;#DB4D6D&#39;, &#39;#E83015&#39;, &#39;#F75C2F&#39;, &#39;#E79460&#39;, &#39;#E98B2A&#39;, &#39;#9B6E23&#39;, &#39;#F7C242&#39;, &#39;#BEC23F&#39;, &#39;#90B44B&#39;, &#39;#66BAB7&#39;, &#39;#1E88A8&#39;) # par(family=(&#39;STKaiti&#39;)) par(family=(&#39;Heiti TC Light&#39;)) mosaicplot(res_table, color=colors, border=0, off = 3, main=&quot;Theft rate of Taipei city (region by hour)&quot;) 5.2.12 (Option) 視覺化殘差分析 # par(family=(&#39;STKaiti&#39;)) par(family=(&#39;Heiti TC Light&#39;)) mosaicplot(res_table, color=T, shade = T, border=0, off = 3, main=&quot;Theft rate of Taipei city (region by hour)&quot;) "],["data-manipulation-wity-tidyverse.html", "Chapter 6 Data Manipulation wity tidyverse 6.1 base to dplyr: TP Theft 6.2 空值（NA）處理 6.3 類別資料分析 6.4 時間軸的視覺化", " Chapter 6 Data Manipulation wity tidyverse 6.1 base to dplyr: TP Theft library(tidyverse) # options(stringsAsFactors = F) # default options in R ver.&gt; 4.0 6.1.1 Reading data # Read by read_csv() # Will raise error # Error in make.names(x) : invalid multibyte string at &#39;&lt;bd&gt;s&lt;b8&gt;&lt;b9&gt;&#39; # df &lt;- read_csv(&quot;data/tp_theft.csv&quot;) # read_csv() with locale = locale(encoding = &quot;Big5&quot;) library(readr) df &lt;- read_csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;) 6.1.2 Cleaning data I Renaming variables by select() Generating variable year Generating variable month Retrieving area selected_df &lt;- df %&gt;% select(id = 編號, cat = 案類, date = `發生日期`, time = `發生時段`, location = `發生地點`) %&gt;% mutate(year = date %/% 10000) %&gt;% mutate(month = date %/% 100 %% 100) %&gt;% mutate(area = stringr::str_sub(location, 4, 6)) %&gt;% mutate(county = stringr::str_sub(location, 1, 3)) 6.1.3 Cleaning data II Filtering out irrelevant data records # readr::guess_encoding(&quot;data/tp_theft.csv&quot;) filtered_df &lt;- selected_df %&gt;% # count(year) %&gt;% View filter(county == &quot;臺北市&quot;) %&gt;% filter(year &gt;= 104) %&gt;% # count(time) %&gt;% View # count(location) %&gt;% filter(!area %in% c(&quot;中和市&quot;, &quot;板橋市&quot;)) 6.1.4 Long to wide form count() two variables spread() spread one variable as columns to wide form # count() then spread() df.wide &lt;- filtered_df %&gt;% count(time, area) %&gt;% spread(area, n, fill=0) 6.1.5 Setting time as row.name for mosaicplot row.names(df.wide) &lt;- df.wide$time df.wide$time &lt;- NULL # Specify fonts for Chinese # par(family=(&#39;STKaiti&#39;)) par(family=(&#39;Heiti TC Light&#39;)) # for mac # Specify colors colors &lt;- c(&#39;#D0104C&#39;, &#39;#DB4D6D&#39;, &#39;#E83015&#39;, &#39;#F75C2F&#39;, &#39;#E79460&#39;, &#39;#E98B2A&#39;, &#39;#9B6E23&#39;, &#39;#F7C242&#39;, &#39;#BEC23F&#39;, &#39;#90B44B&#39;, &#39;#66BAB7&#39;, &#39;#1E88A8&#39;) # mosaicplot() mosaicplot(df.wide, color=colors, border=0, off = 3, main=&quot;Theft rate of Taipei city (region by hour)&quot;) 6.1.6 Clean version library(readr) # options(stringsAsFactors = F) df &lt;- read_csv(&quot;data/臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv&quot;) selected_df &lt;- df %&gt;% select(id = 編號, cat = 案類, date = `發生日期`, time = `發生時段`, location = `發生地點`) %&gt;% mutate(year = date %/% 10000) %&gt;% mutate(month = date %/% 100 %% 100) %&gt;% mutate(area = stringr::str_sub(location, 4, 6)) %&gt;% mutate(county = stringr::str_sub(location, 1, 3)) selected_df %&gt;% count(year) year n 103 1 104 687 105 663 106 560 107 501 108 411 109 304 110 189 111 31 selected_df %&gt;% count(time) %&gt;% head(10) time n 00~02 272 02~04 214 03~05 8 04~06 156 05~07 23 06~08 191 08~10 305 09~11 6 10~12 338 11~03 1 selected_df %&gt;% arrange(time) %&gt;% head(10) id cat date time location year month area county 2 住宅竊盜 1040101 00~02 臺北市文山區萬美里萬寧街1~30號 104 1 文山區 臺北市 3 住宅竊盜 1040101 00~02 臺北市信義區富台里忠孝東路5段295巷6弄1~30號 104 1 信義區 臺北市 6 住宅竊盜 1040102 00~02 臺北市士林區天福里1鄰忠誠路2段130巷1~30號 104 1 士林區 臺北市 12 住宅竊盜 1040105 00~02 臺北市中山區南京東路3段181~210號 104 1 中山區 臺北市 33 住宅竊盜 1040115 00~02 臺北市松山區饒河街181~210號 104 1 松山區 臺北市 74 住宅竊盜 1040131 00~02 臺北市南港區重陽路57巷1~30號 104 1 南港區 臺北市 75 住宅竊盜 1040201 00~02 臺北市北投區中心里中和街31~60號 104 2 北投區 臺北市 92 住宅竊盜 1040210 00~02 臺北市北投區大同路200巷1~30號 104 2 北投區 臺北市 95 住宅竊盜 1040212 00~02 臺北市萬華區萬大路493巷48弄1~30號 104 2 萬華區 臺北市 106 住宅竊盜 1040216 00~02 臺北市信義區吳興街269巷1~30號 104 2 信義區 臺北市 filtered_df &lt;- selected_df %&gt;% # count(year) %&gt;% View filter(year &gt;= 104) %&gt;% filter(!time %in% c(&quot;03~05&quot;, &quot;05~07&quot;, &quot;09~11&quot;, &quot;11~13&quot;, &quot;15~17&quot;, &quot;17~19&quot;, &quot;18~21&quot;, &quot;21~23&quot;, &quot;23~01&quot;)) # count(time) %&gt;% View # count(location) %&gt;% # filter(!area %in% c(&quot;中和市&quot;, &quot;板橋市&quot;)) df.wide &lt;- filtered_df %&gt;% count(time, area) %&gt;% spread(area, n, fill=0) %&gt;% as.data.frame() row.names(df.wide) &lt;- df.wide$time df.wide$time &lt;- NULL par(family=(&#39;Heiti TC Light&#39;)) # for mac # Specify colors colors &lt;- c(&#39;#D0104C&#39;, &#39;#DB4D6D&#39;, &#39;#E83015&#39;, &#39;#F75C2F&#39;, &#39;#E79460&#39;, &#39;#E98B2A&#39;, &#39;#9B6E23&#39;, &#39;#F7C242&#39;, &#39;#BEC23F&#39;, &#39;#90B44B&#39;, &#39;#66BAB7&#39;, &#39;#1E88A8&#39;) # mosaicplot() mosaicplot(df.wide, color=colors, border=0, off = 3, main=&quot;Theft rate of Taipei city (region by hour)&quot;) 6.2 空值（NA）處理 許多統計資料都會有不同程度的NA（缺失值、遺漏值）。缺失值產生的原因不一，可能有以下原因： 資料運算的時候產生的填空值。例如spread()和pivot_wider()經常會產生NA，也經常會指定值（例如0）來取代可能產生的NA。 資料紀錄的時候遺漏某些時間點的資料。 開放資料在開放時已經被整理成階層化、易於展示、一般人易懂的表格型態。此時，若將其讀入也會產生非常大量的NA。例如本章節所要提到的政府各部會預算比例。 紀錄資料筆數非常龐大、來源眾多、紀錄時間不一時，雖然有很多紀錄，但這些紀錄必須要被對齊、刪減，才能夠獲得有意義的可計算資料。例如本章節會提到的世界各國疫苗注射資料。 6.2.1 表格重整：政府預算 raw &lt;- readxl::read_excel(&quot;data/111B歲出政事別預算表.xls&quot;, skip=3, col_names = F) raw %&gt;% head(10) …1 …2 …3 …4 …5 …6 …7 …8 …9 科 目 NA NA NA NA 本年度預算數 上年度預算數 前年度決算數 本年度與上年度 比 較 款 項 目 節 名 稱 及 編 號 NA NA NA NA NA NA NA NA 合 計 2262064189 2135896877 2039353355.829 126167312 NA NA NA NA (1.一般政務支出) 210137299 202634617 190777048.02900001 7502682 1 NA NA NA 3100000000 國務支出 1210301 1186955 1176955.1259999999 23346 NA 1 NA NA 3102010000 總統府 1004797 978916 997305.54599999997 25881 NA NA 1 NA 3102010100 一般行政 920526 896334 882112.75600000005 24192 NA NA 2 NA 3102010200 國務機要 30000 30000 29993.006000000001 NA NA 3 NA 3102010300 國家慶典 15760 15760 45578.949000000001 NA NA 4 NA 3102010400 研究發展 5332 5332 6720.1840000000002 基本清理 重新命名欄位名稱 刪去被當成表格標題的多於列（通常是前兩三列）slice(-(1:2))。 觀察資料，「款」可以說是支出大類的代號，例如總統府、行政支出、立法支出、軍事支出、教育支出等。「科」為該單位底下的部門或者項目，例如「行政支出」下有行政院、主計總處支出等。更底下的細類「目」並非本例的分析對象，所以可以刪除。所以，如果款、科均為空值的話，代表其為更細的「目」。因此篩去款科為空值的所有項目。filter(!is.na(款) | !is.na(科)) 將機構id和機構名稱切分開來，視覺化的時候只會用到機構名稱。separate(機構, c(\"oid\", \"org\"), sep=\"\\n\") names(raw) &lt;- c(&quot;款&quot;, &quot;科&quot;, &quot;目&quot;, &quot;節&quot;, &quot;機構&quot;, &quot;本年度預算&quot;, &quot;上年度預算&quot;, &quot;上年度決算&quot;, &quot;預算差&quot;) cleaned &lt;- raw %&gt;% slice(-(1:2)) %&gt;% filter(!is.na(款) | !is.na(科)) %&gt;% select(-目, -節) %&gt;% separate(機構, c(&quot;oid&quot;, &quot;org&quot;), sep=&quot;\\n&quot;) cleaned %&gt;% head(10) 款 科 oid org 本年度預算 上年度預算 上年度決算 預算差 1 NA 3100000000 國務支出 1210301 1186955 1176955.1259999999 23346 NA 1 3102010000 總統府 1004797 978916 997305.54599999997 25881 NA 2 3102100000 國家安全會議 205504 208039 179649.57999999999 -2535 2 NA 3200000000 行政支出 6134276 5836481 5477154.5810000002 297795 NA 1 3203010000 行政院 1256043 1286646 1268295.23 -30603 NA 2 3203100000 主計總處 1604967 1478173 1578781.8940000001 126794 NA 3 3203300000 人事行政總處 555363 573447 489516.17700000003 -18084 NA 4 3203340000 公務人力發展學院 244346 239453 229852.26199999999 4893 NA 5 3203420000 檔案管理局 787429 646081 443133.20799999998 141348 NA 6 3203900000 大陸委員會 900896 900866 792491.22199999995 30 6.2.1.1 NA處理 觀察一下現在的資料，發現，行政院、主計總處等均屬於行政支出，但行政支出卻自有一列。依照長表格的格式來說，應嘗試把「款」作為機構的變項。所以將款的數字取代為「行政支出」等支出類別的名稱。 cleaned %&gt;% mutate(款 = ifelse(!is.na(款), org, 款)) %&gt;% head(10) 款 科 oid org 本年度預算 上年度預算 上年度決算 預算差 國務支出 NA 3100000000 國務支出 1210301 1186955 1176955.1259999999 23346 NA 1 3102010000 總統府 1004797 978916 997305.54599999997 25881 NA 2 3102100000 國家安全會議 205504 208039 179649.57999999999 -2535 行政支出 NA 3200000000 行政支出 6134276 5836481 5477154.5810000002 297795 NA 1 3203010000 行政院 1256043 1286646 1268295.23 -30603 NA 2 3203100000 主計總處 1604967 1478173 1578781.8940000001 126794 NA 3 3203300000 人事行政總處 555363 573447 489516.17700000003 -18084 NA 4 3203340000 公務人力發展學院 244346 239453 229852.26199999999 4893 NA 5 3203420000 檔案管理局 787429 646081 443133.20799999998 141348 NA 6 3203900000 大陸委員會 900896 900866 792491.22199999995 30 接下來，希望能夠在「款==NA」的地方填入該欄的「前一個值」例如行政支出。查詢一下（關鍵字如「Fill in NA column values with the last value that was not NA」）還真的有這樣的函式可以操作。 library(zoo) cleaned %&gt;% mutate(款 = ifelse(!is.na(款), org, 款)) %&gt;% mutate(款 = zoo::na.locf(款)) %&gt;% head(10) 款 科 oid org 本年度預算 上年度預算 上年度決算 預算差 國務支出 NA 3100000000 國務支出 1210301 1186955 1176955.1259999999 23346 國務支出 1 3102010000 總統府 1004797 978916 997305.54599999997 25881 國務支出 2 3102100000 國家安全會議 205504 208039 179649.57999999999 -2535 行政支出 NA 3200000000 行政支出 6134276 5836481 5477154.5810000002 297795 行政支出 1 3203010000 行政院 1256043 1286646 1268295.23 -30603 行政支出 2 3203100000 主計總處 1604967 1478173 1578781.8940000001 126794 行政支出 3 3203300000 人事行政總處 555363 573447 489516.17700000003 -18084 行政支出 4 3203340000 公務人力發展學院 244346 239453 229852.26199999999 4893 行政支出 5 3203420000 檔案管理局 787429 646081 443133.20799999998 141348 行政支出 6 3203900000 大陸委員會 900896 900866 792491.22199999995 30 太神奇了！看見沒！接下來只要把「科 is NA」的那些該大類支出總數的紀錄給刪除，資料就乾淨了。最後就只會剩下一些資料清理的功伕。完整程式碼可以看下一節。 6.2.1.2 完整程式碼 library(zoo) # raw &lt;- readxl::read_excel(&quot;data/111B歲出政事別預算總表.xls&quot;) raw &lt;- readxl::read_excel(&quot;data/111B歲出政事別預算表.xls&quot;, skip=3, col_names = F) names(raw) &lt;- c(&quot;款&quot;, &quot;科&quot;, &quot;目&quot;, &quot;節&quot;, &quot;機構&quot;, &quot;本年度預算&quot;, &quot;上年度預算&quot;, &quot;上年度決算&quot;, &quot;預算差&quot;) # raw$款 &lt;- na.locf(raw$款) cleaned &lt;- raw %&gt;% filter(!is.na(款) | !is.na(科)) %&gt;% slice(-(1:2)) %&gt;% select(-目, -節) %&gt;% separate(機構, c(&quot;oid&quot;, &quot;org&quot;), sep=&quot;\\n&quot;) %&gt;% mutate(款 = ifelse(!is.na(款), org, 款)) %&gt;% mutate(款 = zoo::na.locf(款)) %&gt;% filter(!is.na(科)) %&gt;% select(-科) %&gt;% type_convert() %&gt;% mutate(上年度預算 = as.numeric(上年度預算), 上年度決算 = as.integer(上年度決算), 預算差 = as.numeric(預算差)) %&gt;% replace_na(list(上年度預算 = 0, 上年度決算 = 0)) %&gt;% mutate(預算差 = 本年度預算 - 上年度預算) 6.2.2 對齊資料。世界各國疫苗接種比例 https://ourworldindata.org/covid-vaccinations - https://github.com/owid/covid-19-data/tree/master/public/data/vaccinations 評估資料概況後可發現這個資料集每一列就是某一個國家某一天所上傳的紀錄。所以，一個國家會有很多列。乍聽之下不難處理，但事實上每個國家不會每天上傳、也不會固定某一天上傳、哪一週、哪一個月開始上傳也不一定，也有可能會漏掉一些月份或週次。所以，制定出一個時間單位（例如週、月）、然後延著時間軸將資料「對齊」，讓每個國家在每個時間單位都有資料。但每個國家疫情發展程度不一，所以也不可能有一個完美的對齊，所以通常會建議就所要觀察的國家進行對齊即可。至於想刪除的那些資料列，幾乎都可以當成是所謂的缺失值。 raw &lt;- read_csv(&quot;data/vaccinations.csv&quot;) dim(raw) ## [1] 99442 16 raw %&gt;% head(20) location iso_code date total_vaccinations people_vaccinated people_fully_vaccinated total_boosters daily_vaccinations_raw daily_vaccinations total_vaccinations_per_hundred people_vaccinated_per_hundred people_fully_vaccinated_per_hundred total_boosters_per_hundred daily_vaccinations_per_million daily_people_vaccinated daily_people_vaccinated_per_hundred Afghanistan AFG 2021-02-22 0 0 NA NA NA NA 0.00 0.00 NA NA NA NA NA Afghanistan AFG 2021-02-23 NA NA NA NA NA 1367 NA NA NA NA 34 1367 0.003 Afghanistan AFG 2021-02-24 NA NA NA NA NA 1367 NA NA NA NA 34 1367 0.003 Afghanistan AFG 2021-02-25 NA NA NA NA NA 1367 NA NA NA NA 34 1367 0.003 Afghanistan AFG 2021-02-26 NA NA NA NA NA 1367 NA NA NA NA 34 1367 0.003 Afghanistan AFG 2021-02-27 NA NA NA NA NA 1367 NA NA NA NA 34 1367 0.003 Afghanistan AFG 2021-02-28 8200 8200 NA NA NA 1367 0.02 0.02 NA NA 34 1367 0.003 Afghanistan AFG 2021-03-01 NA NA NA NA NA 1580 NA NA NA NA 40 1580 0.004 Afghanistan AFG 2021-03-02 NA NA NA NA NA 1794 NA NA NA NA 45 1794 0.005 Afghanistan AFG 2021-03-03 NA NA NA NA NA 2008 NA NA NA NA 50 2008 0.005 Afghanistan AFG 2021-03-04 NA NA NA NA NA 2221 NA NA NA NA 56 2221 0.006 Afghanistan AFG 2021-03-05 NA NA NA NA NA 2435 NA NA NA NA 61 2435 0.006 Afghanistan AFG 2021-03-06 NA NA NA NA NA 2649 NA NA NA NA 66 2649 0.007 Afghanistan AFG 2021-03-07 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-08 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-09 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-10 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-11 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-12 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 Afghanistan AFG 2021-03-13 NA NA NA NA NA 2862 NA NA NA NA 72 2862 0.007 6.2.2.1 按月對齊資料 首先要挑選要拿來做視覺化的資料欄位。這邊所選擇的是people_fully_vaccinated_per_hundred，也就是每百人接種二劑疫苗的人數，相當於接種二劑疫苗的百分比。 接下來便是空值處理，如果這個欄位沒有數值的就直接用drop_na()篩除即可。 這個範例希望把該資料視覺化為Y軸為年、X軸為時間的熱區圖。但整個疫情資料橫亙二年多，如果以週為彙整單位的話，那勢必X軸會有近百個資料點。所以打算以「月」為單位來彙整這些資料，因為且資料中也有不少國家缺數週的資料，所以以月為彙整單位是一個權衡後的選擇（仍可以嘗試用週作為彙整單位試試看）。所以，運用了lubridate::floor_date()來將日期資料轉換為月，例如2022-03-12和2022-03-14都會被轉換為2022-03-01。 依照國家與時間群組彙整資料。接下來就依照各國的月份來做彙整（注意，此時會有不少資料同屬於某個月的資料）。彙整的方法是，經過對「日期」（不是對月）做排序後，僅留下第一筆資料，也就是僅留下最接近月份開頭的資料。經由這樣的操作，會使得各國在每個月剛好留下一筆資料，如下面程式的範例輸出。 library(lubridate) fullvaccinated &lt;- raw %&gt;% select(country = location, date, people_fully_vaccinated_per_hundred) %&gt;% drop_na(people_fully_vaccinated_per_hundred) %&gt;% mutate(m = floor_date(date, unit = &quot;month&quot;)) %&gt;% group_by(country, m) %&gt;% arrange(date) %&gt;% slice(1) %&gt;% ungroup() %&gt;% select(-date) fullvaccinated %&gt;% head(10) country people_fully_vaccinated_per_hundred m Afghanistan 0.14 2021-05-01 Afghanistan 0.36 2021-06-01 Afghanistan 0.48 2021-07-01 Afghanistan 1.08 2021-08-01 Afghanistan 8.00 2021-11-01 Afghanistan 9.42 2021-12-01 Afghanistan 9.56 2022-01-01 Afghanistan 9.82 2022-02-01 Afghanistan 10.75 2022-03-01 Afghanistan 11.38 2022-04-01 6.2.2.2 處理遺漏資料的月份 接下來要處理的是資料紀錄的缺漏值。每個國家登錄資料的時間是很不一致的，某些國家會缺某些月份，或者某些國家是在某年某月以後才開始登記，或者最近沒在登記。但這個範例所要視覺化的資料是接種疫苗的比例，所以即使是現在沒在登記了，但接種比例應列計最後一次資料紀錄的接種比例。 首先我要讓每個國家都有所有月份，這裡應會有某個函式可以做到這件事，但我沒查到這個函式。不過我可以很技巧性地用pivot_wider()（spread()）和pivot_longer()（gather()）來完成這件事。spread()在展開時對於缺少的資料項可以自動補NA。所以我就只要把資料的月份展開後再gather()回來後，就可以自動讓每個國家所擁有的月份資料一致。以下為spread()後的結果，可以觀察到每一列是一個國家，每一欄是個月份，如果當月都沒資料紀錄，那該月的值就會是空值。可以看見空值是相當多的，也就是在那段時間都沒有資料紀錄。 fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% head(10) country 2020-12-01 2021-01-01 2021-02-01 2021-03-01 2021-04-01 2021-05-01 2021-06-01 2021-07-01 2021-08-01 2021-09-01 2021-10-01 2021-11-01 2021-12-01 2022-01-01 2022-02-01 2022-03-01 2022-04-01 2022-05-01 Afghanistan NA NA NA NA NA 0.14 0.36 0.48 1.08 NA NA 8.00 9.42 9.56 9.82 10.75 11.38 NA Africa NA NA 0.00 0.02 0.30 0.36 0.63 1.15 1.66 2.86 4.40 5.93 7.24 9.15 10.78 12.30 15.32 16.56 Albania NA NA 0.00 NA NA 6.32 10.21 14.18 18.46 22.58 27.87 31.04 33.62 36.53 40.26 41.73 42.47 NA Algeria NA NA NA NA NA NA NA NA 1.62 6.72 10.65 10.92 12.45 12.99 13.46 13.70 14.53 NA Andorra NA NA NA 1.52 5.80 6.07 14.14 34.92 45.99 61.69 62.45 NA 65.07 68.58 68.79 68.99 69.04 NA Angola NA NA NA NA NA 0.12 1.11 1.66 2.09 2.71 3.57 5.31 9.05 11.77 14.38 16.53 18.06 NA Anguilla NA NA NA NA 5.18 29.25 36.45 47.34 59.27 59.36 60.54 60.54 60.91 61.37 61.82 63.13 65.28 NA Antigua and Barbuda NA NA NA NA NA 2.61 18.41 28.23 31.33 35.51 43.54 51.60 57.72 59.81 61.27 62.12 NA NA Argentina 0 0 0.26 0.69 1.56 2.24 6.68 9.71 16.35 34.72 50.97 58.37 67.18 73.25 77.69 80.13 81.21 81.64 Armenia NA NA NA NA NA NA 0.40 1.03 1.74 3.64 5.73 9.33 17.42 24.08 28.94 31.97 33.02 NA 在以下的範例輸出可以看到gather()後的結果。注意，需要照國家和月份來排序後才便於觀察。 fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% gather(month, perc, -country) %&gt;% arrange(country, month) %&gt;% head(20) country month perc Afghanistan 2020-12-01 NA Afghanistan 2021-01-01 NA Afghanistan 2021-02-01 NA Afghanistan 2021-03-01 NA Afghanistan 2021-04-01 NA Afghanistan 2021-05-01 0.14 Afghanistan 2021-06-01 0.36 Afghanistan 2021-07-01 0.48 Afghanistan 2021-08-01 1.08 Afghanistan 2021-09-01 NA Afghanistan 2021-10-01 NA Afghanistan 2021-11-01 8.00 Afghanistan 2021-12-01 9.42 Afghanistan 2022-01-01 9.56 Afghanistan 2022-02-01 9.82 Afghanistan 2022-03-01 10.75 Afghanistan 2022-04-01 11.38 Afghanistan 2022-05-01 NA Africa 2020-12-01 NA Africa 2021-01-01 NA 接下來是最技巧性的部分。就接種比例而言是個遞增數列，所以如果這個月有紀錄，但下個月沒紀錄（NA），那下個月的資料應以這個月的資料來替代。此時可以用zoo套件的na.locf()來填NA值，其填NA值的規則是用最後一筆非NA值的資料來替代NA值。但要注意的是，因為資料紀錄可能到第六個月或第七個月才開始紀錄，但在前面的月份都沒資料紀錄，也就是說那些NA值沒有更早的資料紀錄權充填充值。原本na.locf()會把這些找不到參考對象的NA值直接刪除，但我們可以在裡面加一個參數使其不會被刪除（na.locf(perc, na.rm = F)）。 最後，就把這些沒被刪除也沒得參考的早期資料項，用replace_na()填上0即可。 fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% gather(month, perc, -country) %&gt;% arrange(country, month) %&gt;% group_by(country) %&gt;% arrange(month) %&gt;% mutate(perc = zoo::na.locf(perc, na.rm = F)) %&gt;% ungroup() %&gt;% arrange(country, month) %&gt;% head(10) country month perc Afghanistan 2020-12-01 NA Afghanistan 2021-01-01 NA Afghanistan 2021-02-01 NA Afghanistan 2021-03-01 NA Afghanistan 2021-04-01 NA Afghanistan 2021-05-01 0.14 Afghanistan 2021-06-01 0.36 Afghanistan 2021-07-01 0.48 Afghanistan 2021-08-01 1.08 Afghanistan 2021-09-01 1.08 最後，就把這些沒被刪除也沒得參考的早期資料項，用replace_na()填上0即可。大功告成。 fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% gather(month, perc, -country) %&gt;% arrange(country, month) %&gt;% group_by(country) %&gt;% arrange(month) %&gt;% mutate(perc = zoo::na.locf(perc, na.rm = F)) %&gt;% ungroup() %&gt;% arrange(country, month) %&gt;% replace_na(list(perc=0)) %&gt;% arrange(country, month) %&gt;% head(10) country month perc Afghanistan 2020-12-01 0.00 Afghanistan 2021-01-01 0.00 Afghanistan 2021-02-01 0.00 Afghanistan 2021-03-01 0.00 Afghanistan 2021-04-01 0.00 Afghanistan 2021-05-01 0.14 Afghanistan 2021-06-01 0.36 Afghanistan 2021-07-01 0.48 Afghanistan 2021-08-01 1.08 Afghanistan 2021-09-01 1.08 6.2.2.3 完整程式碼 library(lubridate) raw &lt;- read_csv(&quot;data/vaccinations.csv&quot;) fullvaccinated &lt;- raw %&gt;% select(country = location, date, people_fully_vaccinated_per_hundred) %&gt;% drop_na(people_fully_vaccinated_per_hundred) %&gt;% mutate(m = floor_date(date, unit = &quot;month&quot;)) %&gt;% group_by(country, m) %&gt;% arrange(date) %&gt;% slice(1) %&gt;% ungroup() %&gt;% select(-date) vperc_by_month &lt;- fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% gather(month, perc, -country) %&gt;% arrange(country, month) %&gt;% group_by(country) %&gt;% arrange(month) %&gt;% mutate(perc = zoo::na.locf(perc, na.rm = F)) %&gt;% ungroup() %&gt;% arrange(country, month) %&gt;% replace_na(list(perc=0)) 6.3 類別資料分析 這個範例涵括了在做問卷分析時常用的處理步驟。最核心的步驟是將文字陳述的類別資料轉換為便於後續運算的factor或數值資料。如果類別數量過多的時候，在這個過程會順便進行重新分組。例如依照年齡組把填答者分為老年、中壯年、青少年、兒童四組。 raw &lt;- read_rds(&quot;data/tfc_survey.rds&quot;) 6.3.1 清理資料 通常問卷會分為兩種類型的資料，一種是人口統計用的基本資料（如性別、年齡組、教育程度）、另一種是問卷本身要問的題項。以下是常見的問卷型態，包含把年齡從20歲開始每五年作為一組，70歲以上則歸類為一組，共會有十一組。而教育程度則常分為五至六組，但在問卷設計的時候，通常會需要增加「拒答」的選項。如果問卷中包含政黨意識形態，就必須要決定要以黨派作為類別變項，或者以意識形態做順序尺度。以下即為一個順序尺度的案例，從「非常接近泛綠」到「非常接近泛藍」共五個等第，但另增「拒答」選項。 dt &lt;- raw %&gt;% mutate(QA3 = ordered(QA3, levels=c(&quot;20-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55-59&quot;, &quot;60-64&quot;, &quot;65-69&quot;, &quot;70及以上&quot;))) %&gt;% mutate(QA3_lv = ordered(QA3, levels=c(&quot;20-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55-59&quot;, &quot;60-64&quot;, &quot;65-69&quot;, &quot;70及以上&quot;), labels = c(&quot;青年&quot;, &quot;青年&quot;, &quot;壯年&quot;, &quot;壯年&quot;, &quot;壯年&quot;, &quot;中年&quot;, &quot;中年&quot;, &quot;中年&quot;, &quot;中年&quot;, &quot;老年&quot;, &quot;老年&quot;))) %&gt;% mutate(QA4 = ordered(QA4, levels=c(&quot;拒答&quot;, &quot;國小及以下&quot;, &quot;初中、國中&quot;, &quot;高中、高職&quot;, &quot;大專（專科與大學）&quot;, &quot;研究所及以上&quot;), labels=c(&quot;拒答&quot;, &quot;國小以下&quot;, &quot;國中&quot;, &quot;高中職&quot;, &quot;大專&quot;, &quot;研究所以上&quot;))) %&gt;% mutate(QASide=ordered(QASide, exclude=&quot;拒答&quot;, levels=c(&quot;非常接近泛綠&quot;, &quot;接近泛綠&quot;, &quot;都不接近&quot;, &quot;接近泛藍&quot;, &quot;非常接近泛藍&quot;))) 6.3.1.1 轉類別變項為factor 在一開始清理資料的時候，會建議先把類別變數（通常是文字型態）轉為factor型態。常用的函式是用mutate()搭配ordered()來改變變數型態。ordered()會照類別順序來標定該factor所對應到的數字。可以用as.integer()將factor轉為整數後就可以看到各類別的順序。 dt$QA3[1:10] ## [1] 25-29 35-39 35-39 20-24 45-49 25-29 30-34 20-24 20-24 55-59 ## 11 Levels: 20-24 &lt; 25-29 &lt; 30-34 &lt; 35-39 &lt; 40-44 &lt; 45-49 &lt; 50-54 &lt; ... &lt; 70及以上 as.integer(dt$QA3[1:10]) ## [1] 2 4 4 1 6 2 3 1 1 8 6.3.1.2 排除某些類別值 如果有某些類別變數的值（如「拒答」）不想被編入factor，可以在reorder()中加入exclude的參數指定不想被編入類別值。 dt$QASide[1:10] ## [1] 非常接近泛綠 接近泛藍 接近泛綠 接近泛綠 非常接近泛綠 ## [6] 非常接近泛藍 接近泛綠 接近泛綠 接近泛藍 接近泛綠 ## Levels: 非常接近泛綠 &lt; 接近泛綠 &lt; 都不接近 &lt; 接近泛藍 &lt; 非常接近泛藍 as.integer(dt$QASide[1:10]) ## [1] 1 4 2 2 1 5 2 2 4 2 6.3.1.3 群組化類別值 如果有某些類別變數的類別過多，希望再次群組化為較少的組別，如重新群組各年齡層為青年、壯年、中年與老年四個尺度。此時除了levels參數外，可以另外加入labels的參數，指定每個類別變數值所要對應到的群組。以下為群組後的結果，仔細觀察剩下多少個尺度。 dt$QA3[1:10] ## [1] 25-29 35-39 35-39 20-24 45-49 25-29 30-34 20-24 20-24 55-59 ## 11 Levels: 20-24 &lt; 25-29 &lt; 30-34 &lt; 35-39 &lt; 40-44 &lt; 45-49 &lt; 50-54 &lt; ... &lt; 70及以上 as.integer(dt$QA3[1:10]) ## [1] 2 4 4 1 6 2 3 1 1 8 dt$QA3_lv[1:10] ## [1] 青年 壯年 壯年 青年 中年 青年 壯年 青年 青年 中年 ## Levels: 青年 &lt; 壯年 &lt; 中年 &lt; 老年 6.3.2 尺度轉類別指標 Q7 請問您會不會受到假消息影響？ Q8 請問您認為其他人會不會受到假消息的影響？ 對於Q7、Q8的問題是詢問填答者認為自己或他人會不會受到假消息影響，並從「一點也不會」、「不會」、「會」到「絕對會」共分四個等第。Q7分別是「81, 446, 650, 39」、Q8分別是「5, 58, 803, 350」。相較於Q7，Q8的分佈略為左傾，亦即傾向於認為其他人較容易受影響。此時如果想要分析Q7和Q8間的關係，由於各有四個等第，其交叉分析表會有16個項目，相當難以分析。 dt2 &lt;- dt %&gt;% mutate(Q7 = ordered(Q7, levels=c(&quot;一點也不會&quot;, &quot;不會&quot;, &quot;會&quot;, &quot;絕對會&quot;))) %&gt;% mutate(Q8 = ordered(Q8, levels=c(&quot;一點也不會&quot;, &quot;不會&quot;, &quot;會&quot;, &quot;絕對會&quot;))) %&gt;% mutate(Q7_3rd = as.numeric(Q8)-as.numeric(Q7)) %&gt;% mutate(Q7_3rd_lv = ifelse(Q7 %in% c(&quot;一點也不會&quot;, &quot;不會&quot;) &amp; Q8 %in% c(&quot;會&quot;, &quot;絕對會&quot;), &quot;高&quot;, &quot;低&quot;)) %&gt;% mutate(Q7_3rd_lv = ordered(Q7_3rd_lv, levels=c(&quot;低&quot;, &quot;高&quot;))) 這時候一種策略是把這兩題視為順序尺度變數，然後把兩題的分數相減。相減後的分數從「-1, 0, 1, 2, 3」各有「12, 482, 600, 103, 19」，不難猜到會是一個較為集中的分佈，後續僅能當作順序尺度或連續變項來分析，不適合找一個閾值轉類別變項。 另一種策略是，分別先把Q7與Q8的「一點也不會」和「不會」群組為「不會」、再把「會」與「絕對會」群組為「會」，這樣Q7與Q8的交叉分析表會變成2X2的分析表，雖然群組數量比較少，但別忘記Q7的填答結果集中在會與不會、而Q8為一個較為偏右的分佈，集中在「會」和「絕對會」。Q8勢必會造成比例不均的分組。 dt2 %&gt;% count(as.integer(Q8)-as.integer(Q7)) as.integer(Q8) - as.integer(Q7) n -1 12 0 482 1 600 2 103 3 19 最後這題所採行的策略是，做高、低第三人效果分組，也就是根據認為自己「一點也不會」、「不會」受影響，而他人「會」或「絕對會」受影響的重新群組為「高第三人效果組」，其他則為「低第三人效果組」。亦即，分組的一句是在對自己與他人的認知上，無模糊空間的分組方法（也就是認為自己至少不會，和認為別人應該會）。 dt2 %&gt;% count(Q7_3rd_lv) Q7_3rd_lv n 低 746 高 470 6.3.3 Cross-tabulating (xtb &lt;- xtabs(~QA3_lv + Q7_3rd_lv, data=dt2)) 低 高 青年 178 110 壯年 370 199 中年 157 134 老年 41 27 (chi2 &lt;- chisq.test(xtb)) ## ## Pearson&#39;s Chi-squared test ## ## data: xtb ## X-squared = 10.017, df = 3, p-value = 0.01842 vcd::assocstats(xtb) ## X^2 df P(&gt; X^2) ## Likelihood Ratio 9.9301 3 0.01917 ## Pearson 10.0173 3 0.01842 ## ## Phi-Coefficient : NA ## Contingency Coeff.: 0.09 ## Cramer&#39;s V : 0.091 print(round(chi2$observed, 2)) ## Q7_3rd_lv ## QA3_lv 低 高 ## 青年 178 110 ## 壯年 370 199 ## 中年 157 134 ## 老年 41 27 print(round(chi2$expected, 2)) ## Q7_3rd_lv ## QA3_lv 低 高 ## 青年 176.68 111.32 ## 壯年 349.07 219.93 ## 中年 178.52 112.48 ## 老年 41.72 26.28 print(round(chi2$residuals, 2)) ## Q7_3rd_lv ## QA3_lv 低 高 ## 青年 0.10 -0.12 ## 壯年 1.12 -1.41 ## 中年 -1.61 2.03 ## 老年 -0.11 0.14 par(family=&quot;Heiti TC Light&quot;) gplots::balloonplot(t(xtb), xlab=&quot;第三人效果&quot;, ylab=&quot;年齡組&quot;, main=&quot;&quot;, dotsize=4/max(strwidth(40),strheight(40)), text.size=1.5,label.size=2, rowmar=1, colmar=1) par(family=&quot;Heiti TC Light&quot;) corrplot::corrplot(chi2$residuals, is.corr = F) xtb %&gt;% as_tibble() %&gt;% group_by(QA3_lv) %&gt;% mutate(fill = if_else(n == max(n), &quot;orangered&quot;, &quot;skyblue&quot;)) %&gt;% ungroup() %&gt;% mutate(QA3_lv = ordered(QA3_lv, levels=c(&quot;青年&quot;, &quot;壯年&quot;, &quot;中年&quot;, &quot;老年&quot;))) %&gt;% arrange(desc(QA3_lv)) %&gt;% ggplot() + aes(y = QA3_lv, x=Q7_3rd_lv, color = fill, size = n) + scale_size_area(max_size=70, guide = &quot;none&quot;) + geom_point(alpha=0.7) + scale_color_manual(values = c(&quot;orangered&quot;, &quot;skyblue&quot;), guide = &quot;none&quot;) + geom_text(aes( label=n, vjust=1.3, size=10 ), color=&quot;black&quot;,) + theme_minimal() + theme(text = element_text(family=&quot;Heiti TC Light&quot;), title = element_text(family=&quot;Heiti TC Light&quot;)) 6.4 時間軸的視覺化 library(tidyverse) library(lubridate) # options(stringsAsFactors = F) # default option in R &gt; 4.0 6.4.1 文字轉時間 Convert “character time” to R date.time object (POSIXct) ptturl &lt;- &quot;https://github.com/P4CSS/R4CSSData/raw/main/ptt_hang_posts.csv&quot; raw &lt;- read.csv(url(ptturl)) clean &lt;- raw %&gt;% mutate(ptime = as.POSIXct(strptime(ptime, &quot;%Y-%m-%dT%H:%M:%SZ&quot;, tz = &quot;ASIA/Taipeiw&quot;))) raw &lt;- read_csv(url(ptturl)) ?read_csv read_delim R Documentation Read a delimited file (including CSV and TSV) into a tibble Description read_csv() and read_tsv() are special cases of the more general read_delim(). They’re useful for reading the most common types of flat file data, comma separated values and tab separated values, respectively. read_csv2() uses ⁠;⁠ for the field separator and ⁠,⁠ for the decimal point. This format is common in some European countries. Usage read_delim( file, delim = NULL, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy() ) read_csv( file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy() ) read_csv2( file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy() ) read_tsv( file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy() ) Arguments file Either a path to a file, a connection, or literal data (either a single string or a raw vector). Files ending in .gz, .bz2, .xz, or .zip will be automatically uncompressed. Files starting with ⁠http://&amp;#8288;, ⁠https://&amp;#8288;, ⁠ftp://&amp;#8288;, or ⁠ftps://⁠ will be automatically downloaded. Remote gz files can also be automatically downloaded and decompressed. Literal data is most useful for examples and tests. To be recognised as literal data, the input must be either wrapped with I(), be a string containing at least one new line, or be a vector containing at least one string with a new line. Using a value of clipboard() will read from the system clipboard. delim Single character used to separate fields within a record. quote Single character used to quote strings. escape_backslash Does the file use backslashes to escape special characters? This is more general than escape_double as backslashes can be used to escape the delimiter character, the quote character, or to add special characters like ⁠\\n⁠. escape_double Does the file escape quotes by doubling them? i.e. If this option is TRUE, the value ⁠““““⁠ represents a single quote, ⁠\"⁠. col_names Either TRUE, FALSE or a character vector of column names. If TRUE, the first row of the input will be used as the column names, and will not be included in the data frame. If FALSE, column names will be generated automatically: X1, X2, X3 etc. If col_names is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. Missing (NA) column names will generate a warning, and be filled in with dummy names …1, …2 etc. Duplicate column names will generate a warning and be made unique, see name_repair to control how this is done. col_types One of NULL, a cols() specification, or a string. See vignette(“readr”) for more details. If NULL, all column types will be imputed from guess_max rows on the input interspersed throughout the file. This is convenient (and fast), but not robust. If the imputation fails, you’ll need to increase the guess_max or supply the correct types yourself. Column specifications created by list() or cols() must contain one column specification for each column. If you only want to read a subset of the columns, use cols_only(). Alternatively, you can use a compact string representation where each character represents one column: c = character i = integer n = number d = double l = logical f = factor D = date T = date time t = time ? = guess _ or - = skip By default, reading a file without a column specification will print a message showing what readr guessed they were. To remove this message, set show_col_types = FALSE or set ’options(readr.show_col_types = FALSE). col_select Columns to include in the results. You can use the same mini-language as dplyr::select() to refer to the columns by name. Use c() or list() to use more than one selection expression. Although this usage is less common, col_select also accepts a numeric column index. See ?tidyselect::language for full details on the selection language. id The name of a column in which to store the file path. This is useful when reading multiple input files and there is data in the file paths, such as the data collection date. If NULL (the default) no extra column is created. locale The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use locale() to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names. na Character vector of strings to interpret as missing values. Set this option to character() to indicate no missing values. quoted_na Should missing values inside quotes be treated as missing values (the default) or strings. This parameter is soft deprecated as of readr 2.0.0. comment A string used to identify comments. Any text after the comment characters will be silently ignored. trim_ws Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from each field before parsing it? skip Number of lines to skip before reading data. If comment is supplied any commented lines are ignored after skipping. n_max Maximum number of lines to read. guess_max Maximum number of lines to use for guessing column types. See vignette(“column-types”, package = “readr”) for more details. name_repair Handling of column names. The default behaviour is to ensure column names are “unique”. Various repair strategies are supported: “minimal”: No name repair or checks, beyond basic existence of names. “unique” (default value): Make sure names are unique and not empty. “check_unique”: no name repair, but check they are unique. “universal”: Make the names unique and syntactic. A function: apply custom name repair (e.g., name_repair = make.names for names in the style of base R). A purrr-style anonymous function, see rlang::as_function(). This argument is passed on as repair to vctrs::vec_as_names(). See there for more details on these terms and the strategies used to enforce them. num_threads The number of processing threads to use for initial parsing and lazy reading of data. If your data contains newlines within fields the parser should automatically detect this and fall back to using one thread only. However if you know your file has newlines within quoted fields it is safest to set num_threads = 1 explicitly. progress Display a progress bar? By default it will only display in an interactive session and not while knitting a document. The automatic progress bar can be disabled by setting option readr.show_progress to FALSE. show_col_types If FALSE, do not show the guessed column types. If TRUE always show the column types, even if they are supplied. If NULL (the default) only show the column types if they are not explicitly supplied by the col_types argument. skip_empty_rows Should blank rows be ignored altogether? i.e. If this option is TRUE then blank rows will not be represented at all. If it is FALSE then they will be represented by NA values in all the columns. lazy Read values lazily? By default the file is initially only indexed and the values are read lazily when accessed. Lazy reading is useful interactively, particularly if you are only interested in a subset of the full dataset. Note, if you later write to the same file you read from you need to set lazy = FALSE. On Windows the file will be locked and on other systems the memory map will become invalid. Value A tibble(). If there are parsing problems, a warning will alert you. You can retrieve the full details by calling problems() on your dataset. Examples # Input sources ------------------------------------------------------------- # Read from a path read_csv(readr_example(\"mtcars.csv\")) read_csv(readr_example(\"mtcars.csv.zip\")) read_csv(readr_example(\"mtcars.csv.bz2\")) ## Not run: # Including remote paths read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\") ## End(Not run) # Or directly from a string with `I()` read_csv(I(\"x,y\\n1,2\\n3,4\")) # Column types -------------------------------------------------------------- # By default, readr guesses the columns types, looking at `guess_max` rows. # You can override with a compact specification: read_csv(I(\"x,y\\n1,2\\n3,4\"), col_types = \"dc\") # Or with a list of column types: read_csv(I(\"x,y\\n1,2\\n3,4\"), col_types = list(col_double(), col_character())) # If there are parsing problems, you get a warning, and can extract # more details with problems() y &lt;- read_csv(I(\"x\\n1\\n2\\nb\"), col_types = list(col_double())) y problems(y) # File types ---------------------------------------------------------------- read_csv(I(\"a,b\\n1.0,2.0\")) read_csv2(I(\"a;b\\n1,0;2,0\")) read_tsv(I(\"a\\tb\\n1.0\\t2.0\")) read_delim(I(\"a|b\\n1.0|2.0\"), delim = \"|\") t &lt;- &quot;2019-04-12T00:48:19Z&quot; class(t) ## [1] &quot;character&quot; ?strptime strptime R Documentation Date-time Conversion Functions to and from Character Description Functions to convert between character representations and objects of classes “POSIXlt” and “POSIXct” representing calendar dates and times. Usage ## S3 method for class 'POSIXct' format(x, format = \"\", tz = \"\", usetz = FALSE, ...) ## S3 method for class 'POSIXlt' format(x, format = \"\", usetz = FALSE, digits = getOption(\"digits.secs\"), ...) ## S3 method for class 'POSIXt' as.character(x, ...) strftime(x, format = \"\", tz = \"\", usetz = FALSE, ...) strptime(x, format, tz = \"\") Arguments x An object to be converted: a character vector for strptime, an object which can be converted to “POSIXlt” for strftime. tz A character string specifying the time zone to be used for the conversion. System-specific (see as.POSIXlt), but ““ is the current time zone, and ”GMT” is UTC. Invalid values are most commonly treated as UTC, on some platforms with a warning. format A character string. The default for the format methods is “%Y-%m-%d %H:%M:%S” if any element has a time component which is not midnight, and “%Y-%m-%d” otherwise. If options(“digits.secs”) is set, up to the specified number of digits will be printed for seconds. … Further arguments to be passed from or to other methods. usetz logical. Should the time zone abbreviation be appended to the output? This is used in printing times, and more reliable than using “%Z”. digits integer determining the format()ing of seconds when needed. Details The format and as.character methods and strftime convert objects from the classes “POSIXlt” and “POSIXct” to character vectors. strptime converts character vectors to class “POSIXlt”: its input x is first converted by as.character. Each input string is processed as far as necessary for the format specified: any trailing characters are ignored. strftime is a wrapper for format.POSIXlt, and it and format.POSIXct first convert to class “POSIXlt” by calling as.POSIXlt (so they also work for class “Date”). Note that only that conversion depends on the time zone. Since R version 4.2.0, that as.POSIXlt() conversion now treats the non-finite numeric -Inf, Inf, NA and NaN differently (where previously all were treated as NA) and also the format() method for POSIXlt now treats these different non-finite times and dates analogously to type double. The usual vector re-cycling rules are applied to x and format so the answer will be of length of the longer of these vectors. Locale-specific conversions to and from character strings are used where appropriate and available. This affects the names of the days and months, the AM/PM indicator (if used) and the separators in output formats such as %x and %X, via the setting of the LC_TIME locale category. The ‘current locale’ of the descriptions might mean the locale in use at the start of the R session or when these functions are first used. (For input, the locale-specific conversions can be changed by calling Sys.setlocale with category LC_TIME (or LC_ALL). For output, what happens depends on the OS but usually works.) The details of the formats are platform-specific, but the following are likely to be widely available: most are defined by the POSIX standard. A conversion specification is introduced by %, usually followed by a single letter or O or E and then a single letter. Any character in the format string not part of a conversion specification is interpreted literally (and %% gives %). Widely implemented conversion specifications include %a Abbreviated weekday name in the current locale on this platform. (Also matches full name on input: in some locales there are no abbreviations of names.) %A Full weekday name in the current locale. (Also matches abbreviated name on input.) %b Abbreviated month name in the current locale on this platform. (Also matches full name on input: in some locales there are no abbreviations of names.) %B Full month name in the current locale. (Also matches abbreviated name on input.) %c Date and time. Locale-specific on output, “%a %b %e %H:%M:%S %Y” on input. %C Century (00–99): the integer part of the year divided by 100. %d Day of the month as decimal number (01–31). %D Date format such as %m/%d/%y: the C99 standard says it should be that exact format (but not all OSes comply). %e Day of the month as decimal number (1–31), with a leading space for a single-digit number. %F Equivalent to %Y-%m-%d (the ISO 8601 date format). %g The last two digits of the week-based year (see %V). (Accepted but ignored on input.) %G The week-based year (see %V) as a decimal number. (Accepted but ignored on input.) %h Equivalent to %b. %H Hours as decimal number (00–23). As a special exception strings such as ‘⁠24:00:00⁠’ are accepted for input, since ISO 8601 allows these. %I Hours as decimal number (01–12). %j Day of year as decimal number (001–366): For input, 366 is only valid in a leap year. %m Month as decimal number (01–12). %M Minute as decimal number (00–59). %n Newline on output, arbitrary whitespace on input. %p AM/PM indicator in the locale. Used in conjunction with %I and not with %H. An empty string in some locales (for example on some OSes, non-English European locales including Russia). The behaviour is undefined if used for input in such a locale. Some platforms accept %P for output, which uses a lower-case version (%p may also use lower case): others will output P. %r For output, the 12-hour clock time (using the locale’s AM or PM): only defined in some locales, and on some OSes misleading in locales which do not define an AM/PM indicator. For input, equivalent to %I:%M:%S %p. %R Equivalent to %H:%M. %S Second as integer (00–61), allowing for up to two leap-seconds (but POSIX-compliant implementations will ignore leap seconds). %t Tab on output, arbitrary whitespace on input. %T Equivalent to %H:%M:%S. %u Weekday as a decimal number (1–7, Monday is 1). %U Week of the year as decimal number (00–53) using Sunday as the first day 1 of the week (and typically with the first Sunday of the year as day 1 of week 1). The US convention. %V Week of the year as decimal number (01–53) as defined in ISO 8601. If the week (starting on Monday) containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1. (Accepted but ignored on input.) %w Weekday as decimal number (0–6, Sunday is 0). %W Week of the year as decimal number (00–53) using Monday as the first day of week (and typically with the first Monday of the year as day 1 of week 1). The UK convention. %x Date. Locale-specific on output, “%y/%m/%d” on input. %X Time. Locale-specific on output, “%H:%M:%S” on input. %y Year without century (00–99). On input, values 00 to 68 are prefixed by 20 and 69 to 99 by 19 – that is the behaviour specified by the 2018 POSIX standard, but it does also say ‘it is expected that in a future version the default century inferred from a 2-digit year will change’. %Y Year with century. Note that whereas there was no zero in the original Gregorian calendar, ISO 8601:2004 defines it to be valid (interpreted as 1BC): see https://en.wikipedia.org/wiki/0_(year). However, the standards also say that years before 1582 in its calendar should only be used with agreement of the parties involved. For input, only years 0:9999 are accepted. %z Signed offset in hours and minutes from UTC, so -0800 is 8 hours behind UTC. Values up to +1400 are accepted. (Standard only for output. For input R currently supports it on all platforms.) %Z (Output only.) Time zone abbreviation as a character string (empty if not available). This may not be reliable when a time zone has changed abbreviations over the years. Where leading zeros are shown they will be used on output but are optional on input. Names are matched case-insensitively on input: whether they are capitalized on output depends on the platform and the locale. Note that abbreviated names are platform-specific (although the standards specify that in the ‘⁠C⁠’ locale they must be the first three letters of the capitalized English name: this convention is widely used in English-language locales but for example the French month abbreviations are not the same on any two of Linux, macOS, Solaris and Windows). Knowing what the abbreviations are is essential if you wish to use %a, %b or %h as part of an input format: see the examples for how to check. When %z or %Z is used for output with an object with an assigned time zone an attempt is made to use the values for that time zone — but it is not guaranteed to succeed. Not in the standards and less widely implemented are %k The 24-hour clock time with single digits preceded by a blank. %l The 12-hour clock time with single digits preceded by a blank. %s (Output only.) The number of seconds since the epoch. %+ (Output only.) Similar to %c, often “%a %b %e %H:%M:%S %Z %Y”. May depend on the locale. For output there are also %O[dHImMUVwWy] which may emit numbers in an alternative locale-dependent format (e.g., roman numerals), and %E[cCyYxX] which can use an alternative ‘era’ (e.g., a different religious calendar). Which of these are supported is OS-dependent. These are accepted for input, but with the standard interpretation. Specific to R is %OSn, which for output gives the seconds truncated to 0 &lt;= n &lt;= 6 decimal places (and if %OS is not followed by a digit, it uses the setting of getOption(“digits.secs”), or if that is unset, n = 0). Further, for strptime %OS will input seconds including fractional seconds. Note that %S does not read fractional parts on output. The behaviour of other conversion specifications (and even if other character sequences commencing with % are conversion specifications) is system-specific. Some systems document that the use of multi-byte characters in format is unsupported: UTF-8 locales are unlikely to cause a problem. Value The format methods and strftime return character vectors representing the time. NA times are returned as NA_character_. The elements are restricted to 256 bytes, plus a time zone abbreviation if usetz is true. (On known platforms longer strings are truncated at 255 or 256 bytes, but this is not guaranteed by the C99 standard.) strptime turns character representations into an object of class “POSIXlt”. The time zone is used to set the isdst component and to set the “tzone” attribute if tz != ““. If the specified time is invalid (for example ‘⁠“2010-02-30 08:00”⁠’) all the components of the result are NA. (NB: this does means exactly what it says – if it is an invalid time, not just a time that does not exist in some time zone.) Printing years Everyone agrees that years from 1000 to 9999 should be printed with 4 digits, but the standards do not define what is to be done outside that range. For years 0 to 999 most OSes pad with zeros or spaces to 4 characters, and Linux outputs just the number. OS facilities will probably not print years before 1 CE (aka 1 AD) ‘correctly’ (they tend to assume the existence of a year 0: see https://en.wikipedia.org/wiki/0_(year), and some OSes get them completely wrong). Common formats are -45 and -045. Years after 9999 and before -999 are normally printed with five or more characters. Some platforms support modifiers from POSIX 2008 (and others). On Linux the format “%04Y” assures a minimum of four characters and zero-padding. The internal code (as used on Windows and by default on macOS) uses zero-padding by default, and formats %_4Y and %_Y can be used for space padding and no padding. Time zone offsets Offsets from GMT (also known as UTC) are part of the conversion between timezones and to/from class “POSIXct”, but cause difficulties as they are often computed incorrectly. They conventionally have the opposite sign from time-zone specifications (see Sys.timezone): positive values are East of the meridian. Although there have been time zones with offsets like 00:09:21 (Paris in 1900), and 00:44:30 (Liberia until 1972), offsets are usually treated as whole numbers of minutes, and are most often seen in RFC 5322 email headers in forms like -0800 (e.g., used on the Pacific coast of the USA in winter). Format %z can be used for input or output: it is a character string, conventionally plus or minus followed by two digits for hours and two for minutes: the standards say that an empty string should be output if the offset is unknown, but some systems use the offsets for the time zone in use for the current year. Sources Input uses the POSIX function strptime and output the C99 function strftime. However, not all OSes (notably Windows) provided strptime and many issues were found for those which did, so since 2000 R has used a fork of code from ‘⁠glibc⁠’. The forked code uses the system’s strftime to find the locale-specific day and month names and any AM/PM indicator. On some platforms (including Windows and by default on macOS) the system’s strftime is replaced (along with most of the rest of the C-level datetime code) by code modified from IANA’s ‘⁠tzcode⁠’ distribution (https://www.iana.org/time-zones). Note The default formats follow the rules of the ISO 8601 international standard which expresses a day as “2001-02-28” and a time as “14:01:02” using leading zeroes as here. (The ISO form uses no space to separate dates and times: R does by default.) For strptime the input string need not specify the date completely: it is assumed that unspecified seconds, minutes or hours are zero, and an unspecified year, month or day is the current one. (However, if a month is specified, the day of that month has to be specified by %d or %e since the current day of the month need not be valid for the specified month.) Some components may be returned as NA (but an unknown tzone component is represented by an empty string). If the time zone specified is invalid on your system, what happens is system-specific but it will probably be ignored. Remember that in most time zones some times do not occur and some occur twice because of transitions to/from ‘daylight saving’ (also known as ‘summer’) time. strptime does not validate such times (it does not assume a specific time zone), but conversion by as.POSIXct will do so. Conversion by strftime and formatting/printing uses OS facilities and may return nonsensical results for non-existent times at DST transitions. In a C locale %c is required to be “%a %b %e %H:%M:%S %Y”. As Windows does not comply (and uses a date format not understood outside N. America), that format is used by R on Windows in all locales. References International Organization for Standardization (2004, 2000, …) ‘ISO 8601. Data elements and interchange formats – Information interchange – Representation of dates and times.’, slightly updated to International Organization for Standardization (2019) ‘ISO 8601-1:2019. Date and time – Representations for information interchange – Part 1: Basic rules’. For links to versions available on-line see (at the time of writing) https://dotat.at/tmp/ISO_8601-2004_E.pdf and https://www.qsl.net/g1smd/isopdf.htm; for information on the current official version, see https://www.iso.org/iso/iso8601 and https://en.wikipedia.org/wiki/ISO_8601. The POSIX 1003.1 standard, which is in some respects stricter than ISO 8601. See Also DateTimeClasses for details of the date-time classes; locales to query or set a locale. Your system’s help page on strftime to see how to specify their formats. (On some systems, including Windows, strftime is replaced by more comprehensive internal code.) Examples ## locale-specific version of date() format(Sys.time(), \"%a %b %d %X %Y %Z\") ## time to sub-second accuracy (if supported by the OS) format(Sys.time(), \"%H:%M:%OS3\") ## read in date info in format 'ddmmmyyyy' ## This will give NA(s) in some non-English locales; setting the C locale ## as in the commented lines will overcome this on most systems. ## lct &lt;- Sys.getlocale(\"LC_TIME\"); Sys.setlocale(\"LC_TIME\", \"C\") x &lt;- c(\"1jan1960\", \"2jan1960\", \"31mar1960\", \"30jul1960\") z &lt;- strptime(x, \"%d%b%Y\") ## Sys.setlocale(\"LC_TIME\", lct) z ## read in date/time info in format 'm/d/y h:m:s' dates &lt;- c(\"02/27/92\", \"02/27/92\", \"01/14/92\", \"02/28/92\", \"02/01/92\") times &lt;- c(\"23:03:20\", \"22:29:56\", \"01:03:30\", \"18:21:03\", \"16:56:26\") x &lt;- paste(dates, times) strptime(x, \"%m/%d/%y %H:%M:%S\") ## time with fractional seconds z &lt;- strptime(\"20/2/06 11:16:16.683\", \"%d/%m/%y %H:%M:%OS\") z # prints without fractional seconds op &lt;- options(digits.secs = 3) z options(op) ## time zone names are not portable, but 'EST5EDT' comes pretty close. (x &lt;- strptime(c(\"2006-01-08 10:07:52\", \"2006-08-07 19:33:02\"), \"%Y-%m-%d %H:%M:%S\", tz = \"EST5EDT\")) attr(x, \"tzone\") ## An RFC 5322 header (Eastern Canada, during DST) ## In a non-English locale the commented lines may be needed. ## prev &lt;- Sys.getlocale(\"LC_TIME\"); Sys.setlocale(\"LC_TIME\", \"C\") strptime(\"Tue, 23 Mar 2010 14:36:38 -0400\", \"%a, %d %b %Y %H:%M:%S %z\") ## Sys.setlocale(\"LC_TIME\", prev) ## Make sure you know what the abbreviated names are for you if you wish ## to use them for input (they are matched case-insensitively): format(seq.Date(as.Date('1978-01-01'), by = 'day', len = 7), \"%a\") format(seq.Date(as.Date('2000-01-01'), by = 'month', len = 12), \"%b\") format(.POSIXct(Inf)) # \"Inf\" (was NA in R &lt;= 4.1.x) notF &lt;- c(-Inf,Inf,NaN,NA) (fF &lt;- format(.POSIXct(notF))) # was all NA, now the last is still NA (not \"NA\") stopifnot(identical(as.character(notF), fF)) t1 &lt;- strptime(t, &quot;%Y-%m-%dT%H:%M:%SZ&quot;) raw %&gt;% glimpse() ## Rows: 8,317 ## Columns: 7 ## $ plink &lt;chr&gt; &quot;https://www.ptt.cc/bbs/HatePolitics/M.1555035677.A.24B.html&quot;… ## $ board &lt;chr&gt; &quot;HatePolitics&quot;, &quot;HatePolitics&quot;, &quot;HatePolitics&quot;, &quot;HatePolitics… ## $ pcontent &lt;chr&gt; &quot;\\n\\n韓國瑜赴哈佛大學前受訪表示，就是「keeping practice」，盡… ## $ poster &lt;chr&gt; &quot;lovebxcx&quot;, &quot;ikr3699654&quot;, &quot;sunyeah&quot;, &quot;rock720429&quot;, &quot;btm978952… ## $ ptitle &lt;chr&gt; &quot;Re: [新聞] 重申反對一國兩制 韓國瑜：看著我靈魂深&quot;, &quot;Re: [討… ## $ ptime &lt;dttm&gt; 2019-04-12 02:21:14, 2019-04-12 02:13:45, 2019-04-12 02:10:1… ## $ ipaddr &lt;chr&gt; &quot;83.221.204.163&quot;, &quot;114.43.176.110&quot;, &quot;118.163.130.181&quot;, &quot;118.1… 6.4.2 時間作為機率分佈X軸 raw %&gt;% ggplot() + aes(ptime) + geom_density() 6.4.3 逐月統計資料 ?lubridate lubridate-package R Documentation Dates and times made easy with lubridate Description Lubridate provides tools that make it easier to parse and manipulate dates. These tools are grouped below by common purpose. More information about each function can be found in its help documentation. Parsing dates Lubridate’s parsing functions read strings into R as POSIXct date-time objects. Users should choose the function whose name models the order in which the year (‘y’), month (‘m’) and day (‘d’) elements appear the string to be parsed: dmy(), myd(), ymd(), ydm(), dym(), mdy(), ymd_hms()). A very flexible and user friendly parser is provided by parse_date_time(). Lubridate can also parse partial dates from strings into Period objects with the functions hm(), hms() and ms(). Lubridate has an inbuilt very fast POSIX parser. Most of the strptime() formats and various extensions are supported for English locales. See parse_date_time() for more details. Manipulating dates Lubridate distinguishes between moments in time (known as instants()) and spans of time (known as time spans, see Timespan). Time spans are further separated into Duration, Period and Interval objects. Instants Instants are specific moments of time. Date, POSIXct, and POSIXlt are the three object classes Base R recognizes as instants. is.Date() tests whether an object inherits from the Date class. is.POSIXt() tests whether an object inherits from the POSIXlt or POSIXct classes. is.instant() tests whether an object inherits from any of the three classes. now() returns the current system time as a POSIXct object. today() returns the current system date. For convenience, 1970-01-01 00:00:00 is saved to origin. This is the instant from which POSIXct times are calculated. Try unclass(now()) to see the numeric structure that underlies POSIXct objects. Each POSIXct object is saved as the number of seconds it occurred after 1970-01-01 00:00:00. Conceptually, instants are a combination of measurements on different units (i.e, years, months, days, etc.). The individual values for these units can be extracted from an instant and set with the accessor functions second(), minute(), hour(), day(), yday(), mday(), wday(), week(), month(), year(), tz(), and dst(). Note: the accessor functions are named after the singular form of an element. They shouldn’t be confused with the period helper functions that have the plural form of the units as a name (e.g, seconds()). Rounding dates Instants can be rounded to a convenient unit using the functions ceiling_date(), floor_date() and round_date(). Time zones Lubridate provides two helper functions for working with time zones. with_tz() changes the time zone in which an instant is displayed. The clock time displayed for the instant changes, but the moment of time described remains the same. force_tz() changes only the time zone element of an instant. The clock time displayed remains the same, but the resulting instant describes a new moment of time. Timespans A timespan is a length of time that may or may not be connected to a particular instant. For example, three months is a timespan. So is an hour and a half. Base R uses difftime class objects to record timespans. However, people are not always consistent in how they expect time to behave. Sometimes the passage of time is a monotone progression of instants that should be as mathematically reliable as the number line. On other occasions time must follow complex conventions and rules so that the clock times we see reflect what we expect to observe in terms of daylight, season, and congruence with the atomic clock. To better navigate the nuances of time, lubridate creates three additional timespan classes, each with its own specific and consistent behavior: Interval, Period and Duration. is.difftime() tests whether an object inherits from the difftime class. is.timespan() tests whether an object inherits from any of the four timespan classes. Durations Durations measure the exact amount of time that occurs between two instants. This can create unexpected results in relation to clock times if a leap second, leap year, or change in daylight savings time (DST) occurs in the interval. Functions for working with durations include is.duration(), as.duration() and duration(). dseconds(), dminutes(), dhours(), ddays(), dweeks() and dyears() convenient lengths. Periods Periods measure the change in clock time that occurs between two instants. Periods provide robust predictions of clock time in the presence of leap seconds, leap years, and changes in DST. Functions for working with periods include is.period(), as.period() and period(). seconds(), minutes(), hours(), days(), weeks(), months() and years() quickly create periods of convenient lengths. Intervals Intervals are timespans that begin at a specific instant and end at a specific instant. Intervals retain complete information about a timespan. They provide the only reliable way to convert between periods and durations. Functions for working with intervals include is.interval(), as.interval(), interval(), int_shift(), int_flip(), int_aligns(), int_overlaps(), and %within%. Intervals can also be manipulated with intersect, union, and setdiff(). Miscellaneous decimal_date() converts an instant to a decimal of its year. leap_year() tests whether an instant occurs during a leap year. pretty_dates() provides a method of making pretty breaks for date-times. lakers is a data set that contains information about the Los Angeles Lakers 2008-2009 basketball season. Author(s) Maintainer: Vitalie Spinu spinuvit@gmail.com Authors: Garrett Grolemund Hadley Wickham Other contributors: Davis Vaughan [contributor] Ian Lyttle [contributor] Imanuel Costigan [contributor] Jason Law [contributor] Doug Mitarotonda [contributor] Joseph Larmarange [contributor] Jonathan Boiser [contributor] Chel Hee Lee [contributor] Google Inc. [contributor, copyright holder] References Garrett Grolemund, Hadley Wickham (2011). Dates and Times Made Easy with lubridate. Journal of Statistical Software, 40(3), 1-25. https://www.jstatsoft.org/v40/i03/. See Also Useful links: https://lubridate.tidyverse.org https://github.com/tidyverse/lubridate Report bugs at https://github.com/tidyverse/lubridate/issues raw %&gt;% mutate(m = month(ptime)) %&gt;% count(m) %&gt;% ggplot() + aes(m, n) + geom_col() 6.4.4 逐日統計資料（佳） raw %&gt;% filter(ptime &gt;= as_date(&quot;2019-03-18&quot;) &amp; ptime &lt; as_date(&quot;2019-04-01&quot;)) %&gt;% mutate(m = floor_date(ptime, unit = &quot;day&quot;)) %&gt;% count(m) %&gt;% ggplot() + aes(m, n) + geom_col() 6.4.5 每日逐時資料 clean %&gt;% filter(ptime &gt;= as_datetime(&quot;2019-03-25&quot;) &amp; ptime &lt; as_datetime(&quot;2019-04-01&quot;)) %&gt;% mutate(d = floor_date(ptime, unit = &quot;day&quot;)) %&gt;% mutate(h = hour(ptime)) %&gt;% count(d, h) %&gt;% mutate(wd = wday(d, label = F, locale = Sys.getlocale(&quot;LC_TIME&quot;))) %&gt;% mutate(isweekend = ifelse(wd &gt;= 6, &quot;weekend&quot;, &quot;weekday&quot;)) %&gt;% ggplot() + aes(h, n, color = as.character(d)) + geom_line() + facet_wrap(~isweekend) ?ifelse ## Help on topic &#39;ifelse&#39; was found in the following packages: ## ## * base ## * data.table "],["text-processing.html", "Chapter 7 Text Processing 7.1 Tweets 分析", " Chapter 7 Text Processing 7.1 Tweets 分析 應用dplyr和ggplot做社群輿論資料（tweets）的探索性分析，其中除了dplyr和ggplot外，尚用到文字處理（stringr, extract()）、時間處理（lubridate），甚至包含一點keyness分析，為找出兩個群體文本中，對彼此相對突出關鍵字的文本探勘方法。 本範例取材自David Robinson的blog文章「Text analysis of Trump’s tweets confirms he writes only the (angrier) Android half」。David Robinson是「Text Mining with R」的共同作者， 可參考該書籍上的範例「7 Case study: comparing Twitter archives | Text Mining with R (tidytextmining.com)」。 7.1.1 載入並清理資料 R4.0後stringsAsFactors=F變為預設值，便不用再另行用options()設為全域適用的參數。 library(tidyverse) library(lubridate) options(scipen = 999) th &lt;- theme_minimal() + theme(plot.title = element_text(size=24, face=&quot;bold&quot;), legend.title = element_text(size=18, face=&quot;bold&quot;), legend.text = element_text(size=18), axis.title = element_text(hjust=0.5, size=18, face=&quot;italic&quot;), axis.text = element_text(size=18) ) new_style &lt;- function() { font &lt;- &quot;Helvetica&quot; theme( plot.title = element_text(family=font, size=28, face=&quot;bold&quot;), plot.subtitle = element_text(family=font, size=22, margin=margin(9,0,9,0)), plot.caption = element_blank(), legend.position = &quot;top&quot;, legend.text.align = 0, legend.background = element_blank(), # legend.title = element_blank(), legend.key = element_blank(), legend.text = element_text(family=font, size=18, color=&quot;#222222&quot;), axis.text = element_text(family=font, size=18, color=&quot;#222222&quot;), axis.text.x = element_text(margin=margin(5, b = 10)), axis.ticks = element_blank(), axis.line = element_blank(), panel.grid.minor = element_blank(), panel.grid.major.y = element_line(color=&quot;#cbcbcb&quot;), panel.grid.major.x = element_blank(), panel.background = element_blank(), strip.background = element_rect(fill=&quot;white&quot;), strip.text = element_text(size = 22, hjust = 0) ) } load(url(&quot;http://varianceexplained.org/files/trump_tweets_df.rda&quot;)) dim(trump_tweets_df) ## [1] 1512 16 names(trump_tweets_df) ## [1] &quot;text&quot; &quot;favorited&quot; &quot;favoriteCount&quot; &quot;replyToSN&quot; ## [5] &quot;created&quot; &quot;truncated&quot; &quot;replyToSID&quot; &quot;id&quot; ## [9] &quot;replyToUID&quot; &quot;statusSource&quot; &quot;screenName&quot; &quot;retweetCount&quot; ## [13] &quot;isRetweet&quot; &quot;retweeted&quot; &quot;longitude&quot; &quot;latitude&quot; trump_tweets_df %&gt;% select(id, text, created, favoriteCount, retweetCount, statusSource) %&gt;% head(20) ## # A tibble: 20 × 6 ## id text created favoriteCount retweetCount statusSource ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 7626698825… &quot;My … 2016-08-08 15:20:44 9214 3107 &quot;&lt;a href=\\&quot;… ## 2 7626415954… &quot;Joi… 2016-08-08 13:28:20 6981 2390 &quot;&lt;a href=\\&quot;… ## 3 7624396589… &quot;#IC… 2016-08-08 00:05:54 15724 6691 &quot;&lt;a href=\\&quot;… ## 4 7624253718… &quot;Mic… 2016-08-07 23:09:08 19837 6402 &quot;&lt;a href=\\&quot;… ## 5 7624008698… &quot;The… 2016-08-07 21:31:46 34051 11717 &quot;&lt;a href=\\&quot;… ## 6 7622845333… &quot;I s… 2016-08-07 13:49:29 29831 9892 &quot;&lt;a href=\\&quot;… ## 7 7621109187… &quot;Tha… 2016-08-07 02:19:37 19223 5784 &quot;&lt;a href=\\&quot;… ## 8 7621069044… &quot;.@L… 2016-08-07 02:03:39 19543 7930 &quot;&lt;a href=\\&quot;… ## 9 7621044117… &quot;I a… 2016-08-07 01:53:45 75488 24663 &quot;&lt;a href=\\&quot;… ## 10 7620164261… &quot;#Cr… 2016-08-06 20:04:08 23661 7903 &quot;&lt;a href=\\&quot;… ## 11 7619881643… &quot;Hea… 2016-08-06 18:11:50 28069 8561 &quot;&lt;a href=\\&quot;… ## 12 7619369299… &quot;Any… 2016-08-06 14:48:14 35205 13129 &quot;&lt;a href=\\&quot;… ## 13 7619310105… &quot;Cro… 2016-08-06 14:24:43 36936 13250 &quot;&lt;a href=\\&quot;… ## 14 7618928294… &quot;Hil… 2016-08-06 11:53:00 32716 9356 &quot;&lt;a href=\\&quot;… ## 15 7617735761… &quot;Goo… 2016-08-06 03:59:08 34109 10385 &quot;&lt;a href=\\&quot;… ## 16 7617579885… &quot;&#39;Tr… 2016-08-06 02:57:11 19436 8066 &quot;&lt;a href=\\&quot;… ## 17 7617548986… &quot;Tha… 2016-08-06 02:44:55 19330 5418 &quot;&lt;a href=\\&quot;… ## 18 7617118564… &quot;DON… 2016-08-05 23:53:53 30869 16786 &quot;&lt;a href=\\&quot;… ## 19 7616938031… &quot;Tha… 2016-08-05 22:42:08 19431 5681 &quot;&lt;a href=\\&quot;… ## 20 7616538754… &quot;#Ma… 2016-08-05 20:03:29 27568 13869 &quot;&lt;a href=\\&quot;… 7.1.2 萃取資料 Extracting publishing device of tweets # tidyr::extract() # stringr::str_replace trump_tweets_df$statusSource[1] ## [1] &quot;&lt;a href=\\&quot;http://twitter.com/download/android\\&quot; rel=\\&quot;nofollow\\&quot;&gt;Twitter for Android&lt;/a&gt;&quot; tweets &lt;- trump_tweets_df %&gt;% select(id, statusSource, text, created) %&gt;% # mutate(source = str_replace(statusSource, # &quot;.*Twitter for (.*?)&lt;.*&quot;, &quot;\\\\1&quot;)) %&gt;% # mutate(source = str_extract(statusSource, &#39;Twitter for (.*?)&lt;&#39;)) %&gt;% View extract(statusSource, &quot;source&quot;, &quot;Twitter for (.*?)&lt;&quot;) %&gt;% filter(source %in% c(&quot;iPhone&quot;, &quot;Android&quot;)) # Using stringr::str_replace() to mutate a new source variable, replacing tidyr:: # str(tweets) 7.1.3 視覺化探索 7.1.3.1 發文時間 Converting timezone lubridate::with_tz() Extracting hour of timestamp by lubridate::hour() Plotting number of tweets by hour Display y-axis as percentage by scales::percent_format() library(scales) # for percent_format() # lubridate::hour() # lubridate::with_tz() # scales::percent_format() toplot1 &lt;- tweets %&gt;% count(source, hour = hour(with_tz(created, &quot;EST&quot;))) %&gt;% # group_by(source) %&gt;% mutate(percent = n / sum(n)) # ungroup() %&gt;% toplot2 &lt;- tweets %&gt;% count(source, hour = hour(with_tz(created, &quot;EST&quot;))) %&gt;% group_by(source) %&gt;% mutate(percent = n / sum(n)) %&gt;% ungroup() p1 &lt;- toplot1 %&gt;% ggplot() + aes(hour, percent, color = source) + geom_line(size = 1) + scale_color_manual(name = &quot;Phone System&quot;, labels = c(&quot;Android&quot;, &quot;iPhone&quot;), values = c(&quot;royalblue&quot;, &quot;gold&quot;)) + scale_y_continuous(labels = percent_format()) + labs(x = &quot;Hour of day (EST)&quot;, y = &quot;% of tweets&quot;, color = &quot;&quot;) + theme_minimal() p2 &lt;- toplot2 %&gt;% ggplot() + aes(hour, percent, color = source) + geom_line(size = 1) + scale_color_manual(name = &quot;Phone System&quot;, labels = c(&quot;Android&quot;, &quot;iPhone&quot;), values = c(&quot;royalblue&quot;, &quot;gold&quot;)) + scale_y_continuous(labels = percent_format()) + labs(x = &quot;Hour of day (EST)&quot;, y = &quot;% of tweets&quot;, color = &quot;&quot;) + theme_minimal() cowplot::plot_grid( p1, NULL, p2, labels = c(&quot;(a) Normalized by all&quot;, &quot;&quot;, &quot;(b) Normalized in group&quot;), nrow = 1, rel_widths = c(1, 0.1, 1) ) 7.1.3.2 發文附圖 Filtering out tweets starting with \" (those tweets mention #realdonaldtrump) Mutating new variable picture to indicate whether text has picture or not? Counting source by picture Plotting bar chart to compare difference between sources. # library(stringr) toplot &lt;- tweets %&gt;% filter(!str_detect(text, &#39;^&quot;&#39;)) %&gt;% mutate(picture = if_else(str_detect(text, &quot;t.co&quot;), &quot;Picture/link&quot;, &quot;No picture/link&quot;)) %&gt;% count(source, picture) p1 &lt;- toplot %&gt;% ggplot() + aes(source, n, fill = picture) + geom_col(position=&quot;stack&quot;, width = 0.5) + scale_fill_manual(name = &quot;With Picture/link?&quot;, labels = c(&quot;Yes&quot;, &quot;No&quot;), values = c(&quot;royalblue&quot;, &quot;gold&quot;)) + labs(x = &quot;&quot;, y = &quot;Number of tweets&quot;, fill = &quot;&quot;) + theme_minimal() p2 &lt;- toplot %&gt;% ggplot() + aes(source, n, fill = picture) + geom_col(position=&quot;dodge&quot;) + scale_fill_manual(name = &quot;With Picture/link?&quot;, labels = c(&quot;Yes&quot;, &quot;No&quot;), values = c(&quot;royalblue&quot;, &quot;gold&quot;)) + labs(x = &quot;&quot;, y = &quot;Number of tweets&quot;, fill = &quot;&quot;) + theme_minimal() cowplot::plot_grid( p1, NULL, p2, labels = c(&quot;(a) Stacked&quot;, &quot;&quot;, &quot;(b) Dodged&quot;), nrow = 1, rel_widths = c(1, 0.1, 1) ) 7.1.4 Keyness library(tidytext) # unnest_tokens() library(stringr) # str_detect(), str_replace_all() # View(test) # stop_words$word tweet_words &lt;- tweets %&gt;% filter(!str_detect(text, &#39;^&quot;&#39;)) %&gt;% mutate(text = str_replace_all(text, &quot;https://t.co/[A-Za-z\\\\d]+|&amp;amp;&quot;, &quot;&quot;)) %&gt;% # unnest_tokens(word, text) %&gt;% # unnest_tokens(word, text, token = &quot;regex&quot;, pattern = &quot;[^A-Za-z\\\\d#@&#39;]&quot;) %&gt;% mutate(word = str_split(text, &quot; &quot;)) %&gt;% select(id, text, word, everything()) %&gt;% unnest(word) %&gt;% filter(!word %in% stop_words$word, str_detect(word, &quot;[a-z]&quot;)) # View(tweet_words) tweet_words %&gt;% count(word, sort = TRUE) %&gt;% head(20) %&gt;% mutate(word = reorder(word, n)) %&gt;% ggplot(aes(word, n)) + geom_col(fill = &quot;royalblue&quot;) + ylab(&quot;Occurrences&quot;) + coord_flip() + theme_minimal() + theme(axis.text = element_text(size=10)) 7.1.4.1 詞頻差異 test &lt;- tweet_words %&gt;% count(word, source) %&gt;% filter(n &gt;= 5) %&gt;% pivot_wider(names_from = source, values_from = n, values_fill = 0) # View(test) word_by_source &lt;- tweet_words %&gt;% count(word, source) %&gt;% filter(n &gt;= 5) %&gt;% pivot_wider(names_from = source, values_from = n, values_fill = 0) %&gt;% # spread(source, n, fill = 0) %&gt;% ungroup() sum(word_by_source$iPhone) ## [1] 1383 sum(word_by_source$Android) ## [1] 2132 android_iphone_ratios &lt;- word_by_source %&gt;% mutate(iPhone = (iPhone+1)/sum(iPhone+1)) %&gt;% mutate(Android = (Android+1)/sum(Android+1)) %&gt;% # mutate_at(.cols = vars(iPhone, Android), # .funs = funs((. + 1) / sum(. + 1))) %&gt;% mutate(logratio = log2(Android / iPhone)) %&gt;% arrange(desc(logratio)) 7.1.4.2 視覺化log-ratio android_iphone_ratios %&gt;% group_by(logratio &gt; 0) %&gt;% top_n(15, abs(logratio)) %&gt;% ungroup() %&gt;% mutate(word = reorder(word, logratio)) %&gt;% ggplot(aes(word, logratio, fill = logratio &lt; 0)) + geom_col() + coord_flip() + ylab(&quot;Android / iPhone log ratio&quot;) + scale_fill_manual(name = &quot;&quot;, labels = c(&quot;Android&quot;, &quot;iPhone&quot;), values = c(&quot;royalblue&quot;, &quot;gold&quot;)) + theme_minimal() + theme(axis.text = element_text(size=14)) "],["crawler.html", "Chapter 8 Crawler 8.1 Scraping 104.com", " Chapter 8 Crawler 8.1 Scraping 104.com 8.1.1 Complete Code library(tidyverse) library(httr) library(jsonlite) # options(stringsAsFactors = F) all.df &lt;- tibble() refer_url &lt;- &quot;https://www.104.com.tw&quot; for(p in 1:10){ url &lt;- str_c(&#39;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8&amp;order=12&amp;asc=0&amp;page=&#39;, p, &quot;&amp;mode=s&amp;jobsource=2018indexpoc&quot;) print(p) res &lt;- GET(url, add_headers(&quot;referer&quot;=refer_url)) %&gt;% content(&quot;text&quot;) %&gt;% fromJSON() res$data$list$tags &lt;- NULL res$data$list$link &lt;- NULL all.df &lt;- bind_rows(all.df, res$data$list) } all.df$jobNo %&gt;% unique %&gt;% length 8.1.2 Step-by-Step 8.1.2.1 Get the first pages Must loading the second page url1 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=1&amp;mode=s&amp;jobsource=2018indexpoc&quot; # Assigning the 2nd page data url to url2 url2 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8&amp;order=14&amp;asc=0&amp;page=2&amp;mode=s&amp;jobsource=2018indexpoc&quot; # Assigning the 3rd page data url to url3 url3 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=3&amp;mode=s&amp;jobsource=2018indexpoc&quot; # Getting back the url1 data, assigning to result1 res &lt;- GET(url2, config = add_headers(&quot;Referer&quot; = &quot;https://www.104.com.tw/&quot;)) res1 &lt;- content(res, &quot;text&quot;) %&gt;% fromJSON() result2 &lt;- fromJSON(content(GET(url2), &quot;text&quot;)) # Tracing variable result2 and finding the data.frame, assigning to df2 df2 &lt;- res1$data$list 8.1.2.2 Get the first page by modifying url # Guessing the 1st page data url to url1 url1 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=1&amp;mode=s&amp;jobsource=2018indexpoc&quot; # Getting back the 1st page data url1 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=1&amp;mode=s&amp;jobsource=2018indexpoc&quot; result1 &lt;- fromJSON(content(GET(url1), &quot;text&quot;)) df1 &lt;- result1$data$list 8.1.2.3 Combine two data with the same variables # all.df &lt;- bind_rows(df1, df2) # will raise error # Error in bind_rows_(x, .id) : # Argument 31 can&#39;t be a list containing data frames 8.1.2.4 Drop out hierarchical variables Preserving numeric or character, dropping list of data.frame by assigning NULL to the variable # Drop list and data.frame inside the data.frame df1$link &lt;- NULL df1$tags &lt;- NULL df2$link &lt;- NULL df2$tags &lt;- NULL # Re-binding two data.frame df1 and df2 all.df &lt;- bind_rows(df1, df2) 8.1.2.5 Dropping hierarchical variables by dplyr way # Getting the 1st page data and dropping variable tags and link # Assigning to df1 df1 &lt;- result1$data$list %&gt;% select(-tags, -link) # Getting the 2nd page data and dropping variable tags and link # Assigning to df2 df2 &lt;- result2$data$list %&gt;% select(-tags, -link) # binding df1 and df2 all.df &lt;- bind_rows(df1, df2) 8.1.2.6 Finding out the last page number # Tracing the number of pages in result1 last_page_num &lt;- result1$data$totalPage # Checking the availability of the last page # Examining if the last page data available by re-composing URL with paste0() url.last_page &lt;- paste0(&quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=&quot;, last_page_num, &quot;&amp;mode=s&amp;jobsource=2018indexpoc&quot;) # Getting back and parsing the last page data result.last_page &lt;- fromJSON(content(GET(url.last_page), &quot;text&quot;)) 8.1.2.7 Using for-loop to get all pages for(p in 1:last_page_num){ url &lt;- paste0(&quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=&quot;, p, &quot;&amp;mode=s&amp;jobsource=2018indexpoc&quot;) result &lt;- fromJSON(content(GET(url), &quot;text&quot;)) temp.df &lt;- select(result$data$list) print(paste(p, nrow(temp.df))) } 8.1.2.8 combine all data.frame # The 1st url of the query url1 &lt;- &quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=1&amp;mode=s&amp;jobsource=2018indexpoc&quot; # Getting back the 1st page data result1 &lt;- fromJSON(content(GET(url1), &quot;text&quot;)) # Tracing and getting total number of page last_page_num &lt;- result1$data$totalPage # Truncating hierarchical variables: link and tags all.df &lt;- select(result1$data$list, -link, -tags) # for-loop to getting back data and joining them for(p in 1:last_page_num){ url &lt;- paste0(&quot;https://www.104.com.tw/jobs/search/list?ro=0&amp;kwop=7&amp;keyword=%E7%88%AC%E8%9F%B2&amp;order=1&amp;asc=0&amp;page=&quot;, p, &quot;&amp;mode=s&amp;jobsource=2018indexpoc&quot;) result &lt;- fromJSON(content(GET(url), &quot;text&quot;)) temp.df &lt;- select(result$data$list) all.df &lt;- bind_rows(all.df, temp.df) print(paste(p, nrow(all.df))) } "],["visualization.html", "Chapter 9 Visualization 9.1 ggplot簡介 9.2 繪圖基礎：折線圖 9.3 圖表調整 9.4 視覺化說故事的技巧 9.5 COLORS", " Chapter 9 Visualization 9.1 ggplot簡介 本節著重在介紹ggplot的基本概念與設定。不同類型的圖表則在下一節「ggplot圖表類型(II)」 可在一開始便透過knitr::opts_chunk$set(echo = TRUE, fig.width = 2, fig.asp = 0.4)來一次設定所有圖片。fig.width = 8與fig.height = 6 是以英吋（inches）為單位，或用fig.dim = c(8, 6)一次設定長寬1。echo = TRUE是設定knit出輸出格式（如html）時，也要包含程式碼。如果echo = FALSE的話，就只會輸出文字和圖形。 9.2 繪圖基礎：折線圖 9.2.1 繪圖三要素 用ggplot來繪製圖形有三個基本函式ggplot() + aes() + geom_圖表類型。 指定要進行繪圖ggplot()：用%&gt;%將資料（dataframe）pipe給ggplot()後，底下各增添的繪圖選項都用+的符號，類似不斷修正繪圖結果的意思。 指定X／Y軸與群組因子aes()：指定圖表的X/Y軸分別是什麼變數，有些圖表只需要單一個變數（例如Density-chart和Histogram），有些需要X/Y兩個變數（例如Scatter-chart）什麼的變數要做視覺化，Boxplot甚至可以直接指定最大、最小、Q1、Q3和Median等多個變數。 指定要繪製的圖表類型。例如Line-chart為geom_line()、Scatter-chart為geom_point()、Bar-chart為geom_col()或geom_bar()。查閱ggplot cheat sheet可以快速翻閱有哪些圖表類型。 ggplot-cheat-sheet ggplot() 會秀出預備要繪製的繪圖區 tibble(a=1:5, b=5:1) %&gt;% ggplot() 指定X／Y軸與群組因子aes()：aes()會在繪圖區上繪製X與Y軸 tibble(a=1:5, b=5:1) %&gt;% ggplot() + aes(x=a, y=b) 指定要繪製的圖表類型。例如Line-chart為geom_line()、 tibble(a=1:5, b=5:1) %&gt;% ggplot() + aes(x=a, y=b) + geom_line() 此圖為一雙變數的圖，基於雙變數，可以將不同的圖同時繪製在同一個繪圖區上。例如以下同時繪製了geom_line()與geom_plot()。 tibble(a=1:5, b=5:1) %&gt;% ggplot() + aes(x=a, y=b) + geom_line() + geom_point() 9.2.2 範例-紐時世代貧富不均 Teach About Inequality With These 28 New York Times Graphs - The New York Times (nytimes.com) ggplot是以變數為基礎的視覺化套件，也就是說，當準備好dataframe後，就可以在ggplot中指定要用哪些變數來繪圖。也因此，務必把dataframe整理為tidy型態，也就是長表格（long-form）的型態。整理完資料後，我會習慣地用names(plot)或glimpse(plot)來看一下該資料所有的變項，好可以在下一階段的繪圖做參考。 NW &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(Category, year, Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% ungroup() NW %&gt;% glimpse() ## Rows: 66 ## Columns: 3 ## $ Category &lt;chr&gt; &quot;Less than 35&quot;, &quot;35-44&quot;, &quot;45-54&quot;, &quot;55-64&quot;, &quot;65-74&quot;, &quot;75 or o… ## $ year &lt;dbl&gt; 1989, 1989, 1989, 1989, 1989, 1989, 1992, 1992, 1992, 1992, … ## $ Net_Worth &lt;dbl&gt; 16.17019, 112.47530, 195.11630, 195.25554, 154.34277, 144.29… 這是預期視覺化的結果 先將year和Net_worth分別繪製在X與Y軸上，並用geom_line()繪製為折現圖。結果圖表中呈現鋸齒狀的折線，看似有問題，但其實是合理的。因為year是一個離散變數，而我們希望每個年齡層一條線的話，那就要照年齡層來分組。也因此，每一年都有有每個年齡層的資料，當我們把「年」作為X軸時，自然同一年就會有數筆不同年齡層的資料，因此才會是鋸齒狀的。 NW %&gt;% ggplot() + aes(x=year, y=Net_Worth) + geom_line() 不同的圖表類型是可以疊加在同一張圖上的。我們也可以把geom_point() 另一種圖表型態加入，也是可以的，兩者的X與Y不相衝突。geom_line()、geom_point()、geom_text()三者會經常伴隨出現。 NW %&gt;% ggplot() + aes(x=year, y=Net_Worth) + geom_line() + geom_point() 9.2.3 加入自變項群組 上圖是我們把多個年齡層的逐年資料畫在同一條折線上，所以會呈現鋸齒狀折現的狀況。但這些年齡層並非在同一條線上呀？因此，我們要根據Category這個變數來做分組。 NW %&gt;% ggplot() + aes(x=year, y=Net_Worth, group=Category) + geom_line() + geom_point(stat=&quot;identity&quot;) 如希望不同線條上不一樣的色彩，應指定color=Category。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() 用color、fill或group來做分組？ geom_line()的色彩是在線，而不是在面上。如果色彩是在點（如geom_point()）或線（geom_line()）上，就是用color來指定顏色。但如果是如類似下面的例子，用geom_area()來視覺化的話，因為顏色填的是面，所以要用fill=Category。以下範例甚至同時指定color=Category, fill=Category。但折線圖如果要用geom_area()來視覺化的話，最好要上顏色的不要超過二個，不然就會像底下這個例子一樣，即使設定alpha=0.2的半透明，仍然會看不懂哪些顏色疊在一起。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category, fill=Category) + geom_area(position=&quot;dodge&quot;, alpha=0.2) 9.3 圖表調整 9.3.1 點線型態 下面的例子同時用了geom_line()和geom_point()，且分別設定了線寬（size=1）、點的大小(size=2)，折線型態（linetype=\"dashed\"）、半透明程度（alpha）。 ggplot2 line types : How to change line types of a graph in R software? - Easy Guides - Wiki - STHDA NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line(size=1, linetype = &quot;dashed&quot;, alpha=0.5) + geom_point(size=2, color=&quot;dimgrey&quot;, alpha=0.5) 9.3.2 標題、標籤與圖說 Titles, labels, and legend 設定標題與X／Y軸標題（法一）：以下設定了圖表的圖表標題、和X軸與Y軸的軸標題（xlab與ylab）。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + xlab(&quot;Year&quot;) + ylab(&quot;Net Worth&quot;) + ggtitle(&quot;Net Worth by year grouped by age groups&quot;) 設定標題與X／Y軸標題（法二）：這是一次設定圖表標題（title）、次標題（suttitle）、X軸與Y軸標題的方法。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, subtitle = &quot;Source from: ...&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) 調整X軸與Y軸標題位置的：必須要透過theme()來設定axis.title.x = element_text(hjust=1)。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) + theme(axis.title.x = element_text(hjust=1), axis.title.y = element_text(hjust=1)) 去除X／Y軸標題（不佳）：直接將空字串Assign給title、x、與y即可。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + labs(title = &quot;&quot;, x = &quot;&quot;, y = &quot;&quot;) 去除X／Y軸標題（較佳）：透過設定theme()來調整。可發現透過這種設定方法，原本標題和X／Y軸標題的邊界空間就會被釋放出來。 # No extra space for xlab, ylab and title NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line(show.legend = F) + theme_minimal() + theme(plot.title = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) 9.3.3 字體樣式 調整字型會建議都從theme()來做調整，所有圖面上看得到的字都有相對應的變數可以調整字型。例如以下的例子中，把標題的字型大小調整為14粗體、X與Y軸的字型則調整了向右對齊、10粗斜體、顏色為dimgrey。 NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) + theme(plot.title = element_text(size=14, face=&quot;bold&quot;), axis.title.x = element_text(hjust=1, size=10, color=&quot;dimgrey&quot;, face=&quot;bold.italic&quot;), axis.title.y = element_text(hjust=1, size=10, color=&quot;dimgrey&quot;, face=&quot;bold.italic&quot;) ) 9.3.4 圖表主題色調 ggplot也有其圖表主題色調。之前範例的灰色圖表背景就是預設的主題，ggplot中還有好幾個預設圖表主題可以選，例如theme_minimal()或theme_tw()等等。 Modify components of a theme — theme • ggplot2 (tidyverse.org) bbplot/bbc_style.R at master · bbc/bbplot (github.com) NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() 9.3.5 預設主題 如果希望所有的圖表都有一致的顏色和排版的調性，可以在一開始編輯Rmd的時候就設計好一套theme()並指給一個變數（例如以下的th）。 th &lt;- theme(plot.title = element_text(size=14, face=&quot;bold&quot;), axis.title.x = element_text(hjust=1, size=10, color=&quot;dimgrey&quot;, face=&quot;bold.italic&quot;), axis.title.y = element_text(hjust=1, size=10, color=&quot;dimgrey&quot;, face=&quot;bold.italic&quot;) ) NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line(linetype = &quot;dashed&quot;, alpha=0.5) + geom_point(size=2, color=&quot;dimgrey&quot;, alpha=0.5) + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) + th 9.3.6 顯示中文字體 Python和R這些程式語言的預設視覺化套件都沒辦法顯示中文，所以如果要顯示中文的話，就要指定圖表標題、X、Y軸標籤、圖說和各個部件的字型。因為我在Mac上繪圖，所以我將字型指定為Heiti TC Light。如果想知道自己的電腦上有什麼可以用，可以到電腦的字體簿上查找中文字體名稱，或者上網google「ggplot 中文字型選擇」。 county &lt;- read_csv(&quot;data/tw_population_opendata110N010.csv&quot;) %&gt;% slice(-1, -(370:375)) %&gt;% type_convert() %&gt;% mutate(county = str_sub(site_id, 1, 3)) %&gt;% group_by(county) %&gt;% summarize( area = sum(area), people_total = sum(people_total) ) %&gt;% ungroup() 下面這是一個長條圖的範例（barplot，不是histogram）。Barplot可以直接指定X軸為縣市（county）和Y軸為總人口數（people_total），但是要用geom_col()而非geom_bar()。除此之外，Bar的顏色有「面」的特徵，所以若要自訂整條bar的顏色，要用fill而非color，color只會是每條Bar的外框。 county %&gt;% arrange(desc(people_total)) %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;lightgrey&quot;, color=&quot;black&quot;) + theme_minimal() 舉例來說，中文字型可以是標楷體（BiauKai）、宋體（Songti TC）、黑體（Heiti TC Light）、蘋方（PingFang TC）、Noto（Noto Sans CJK TC） th &lt;- theme(title = element_text(family=&quot;Heiti TC Light&quot;), text = element_text(family=&quot;Heiti TC Light&quot;), axis.text.y = element_text(family=&quot;PingFang TC&quot;), axis.text.x = element_text(family=&quot;Heiti TC Light&quot;), legend.text = element_text(family=&quot;Heiti TC Light&quot;), plot.title = element_text(family=&quot;Heiti TC Light&quot;) ) county %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;skyblue&quot;) + theme_minimal() + th + theme(axis.text.x = element_text(angle = 45)) 9.3.7 X/Y軸方向 調整圖表方向 county %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;skyblue&quot;) + coord_flip() + theme_minimal() + th + theme(axis.text.x = element_text(angle = 45)) 通常coord_flip()後往往會希望這些bar會是由上而下排序好的，但用arrange(desc(people_total)是無法解決問題的，因為Y軸原本會是照Y軸的刻度排列，而不是Y軸的數值。所以，要被排序的應該是Y軸的「文字」也就是那些縣市。因此，我們需要將該縣市轉為factor（1~n），並且讓這些縣市被安排的factor數值照people_total排列，因此要用mutate(county = reorder(county, people_total))。reorder()是一個將文字轉factor的函式，但在此特別指定照people_total的編排。 county %&gt;% # arrange(desc(people_total) %&gt;% mutate(county = reorder(county, people_total)) %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;skyblue&quot;) + coord_flip() + theme_minimal() + th 9.4 視覺化說故事的技巧 「說故事」才是整則資料新聞的核心，在運用圖表來輔助敘事時，應搭配說理說服的內容來突顯（highlight）圖面上的特徵，而不是留待讀者自己觀察。以下有三種highlight圖表部分資料的方法。第一個方法是在繪圖時用+ scale_color_manual()或+ scale_fill_manual()指定顏色給不同群組；方法二是利用gghighlight這個套件來指定要上色的群組，而且gghighlight可以和fill與color相互搭配，仍然可以用scale_fill_manual和scale_color_manual來指定顏色。但會有個狀況是，如果原本沒群組那怎麼辦？就自己用mutate()打造群組就好。方法各有利弊與使用時機。 9.4.1 依群組指定顏色 scale_color_manual() 與scale_fill_manual() NW %&gt;% ggplot() + aes(year, Net_Worth, color = Category) + geom_line() + scale_color_manual( limits=c(&quot;65-74&quot;, &quot;35-44&quot;), # original chart group values=c(&quot;gold&quot;, &quot;skyblue&quot;), # map to color name=&quot;Age group&quot;, # legend title breaks=c(&quot;65-74&quot;, &quot;35-44&quot;), # original legend group labels labels=c(&quot;elder(65-74)&quot;,&quot;younger(35-44)&quot;), # map to new labels na.value = &quot;lightgrey&quot; # color for other groups ) + theme_minimal() 9.4.2 使用gghighlight套件 library(gghighlight) NW %&gt;% ggplot() + aes(year, Net_Worth, color = Category) + geom_line() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + theme_minimal() + scale_x_continuous(breaks = NULL) + theme(panel.background = element_rect(fill = &quot;whitesmoke&quot;, colour = &quot;whitesmoke&quot;, size = 0.5, linetype = &quot;solid&quot;)) 使用gghighlight仍能自己使用scale_color_manual()來指定顏色 NW %&gt;% ggplot() + aes(year, Net_Worth, color = Category) + geom_line() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + scale_color_manual( limits=c(&quot;65-74&quot;, &quot;35-44&quot;), # original chart group values=c(&quot;gold&quot;, &quot;skyblue&quot;)) + # map to color theme_minimal() 9.4.3 為視覺化建立群組 這個方法是在原本的資料並沒有可以作為color或fill的因子，所以自行創建一個要突顯的群組。 county %&gt;% mutate(group = if_else(county %in% c(&quot;新竹縣&quot;, &quot;新竹市&quot;), &quot;highlight&quot;, &quot;other&quot;)) %&gt;% mutate(county = reorder(county, people_total)) %&gt;% ggplot() + aes(county, people_total, fill=group) %&gt;% geom_col() + scale_fill_manual(values=c(&quot;highlight&quot;=&quot;Khaki&quot;, &quot;other&quot;=&quot;lightgrey&quot;)) + guides(fill=&quot;none&quot;) + coord_flip() + theme_minimal() + th 但事實上也可以用gghighlight直接達成 county %&gt;% mutate(county = reorder(county, people_total)) %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;deeppink&quot;) + gghighlight(county %in% c(&quot;新竹縣&quot;, &quot;新竹市&quot;)) + guides(fill=&quot;none&quot;) + coord_flip() + theme_minimal() + th 9.5 COLORS 參考資料：5.4 Control the size of plots/images | R Markdown Cookbook (bookdown.org)↩︎ "],["chart-types.html", "Chapter 10 CHART TYPES", " Chapter 10 CHART TYPES "],["COORDINATE.html", "Chapter 11 COORDINATE 11.1 排序以展示分佈 11.2 用Log-scale放大長尾頭部 11.3 Square-root scale 11.4 座標軸從數值到增加值 11.5 等比例座標軸", " Chapter 11 COORDINATE Chap3 Coordination &amp; Axis Fundamentals of Data Visualization (clauswilke.com) Chapter 8 Visualizing distributions: Empirical cumulative distribution functions and q-q plots 11.1 排序以展示分佈 學術論文若要呈現一群數據的分佈時，最常用的是密度（分佈）函數、累積分佈函數，最常視覺化的方法是密度分佈圖（geom_density()）或直方圖（geom_histogram())。然而，對新聞等強調「說故事」的文體而言，說故事的技巧往往不是「那一群資源多或資源少的對象」，而經常要直指「那個對象」，要能夠看得見所敘述的對象在圖中的位置。此時，用密度分佈來呈現的話，只能看出，該對象在分佈的某個位置；但可以改用將資料對象根據某個數據來排序後，繪製折現圖的方式來表現。例如，若要繪製一個班級的成績分佈，通常X軸是分數（組），Y軸是獲得該分數（組）的人數；但其實可以將個體依照分數來做排序，Y軸不是某個分數（組）的個數，而是每個排序後的個體，而且以排序後的序號（Ranking）來表示。用折線圖繪製後，一樣可以看出分數的分佈，但卻能夠直接標記敘事中的某個對象是Y軸中得哪個點。 11.1.1 Figure 3.5: Population numbers of Texas counties relative to their median value. Select counties are highlighted by name. The dashed line indicates a ratio of 1, corresponding to a county with median population number. The most populous counties have approximately 100 times more inhabitants than the median county, and the least populous counties have approximately 100 times fewer inhabitants than the median county. Data source: 2010 Decennial U.S. Census. See What’s Going On in This Graph? | Vaccination by Country fromWhat Data Shows About Vaccine Supply and Demand in the Most Vulnerable Places - The New York Times (nytimes.com) The original chart is animated along the timeline.What Data Shows About Vaccine Supply and Demand in the Most Vulnerable Places - The New York Times (nytimes.com) 11.2 用Log-scale放大長尾頭部 raw &lt;- read_csv(&quot;data/opendata107Y020.csv&quot;, show_col_types = FALSE) %&gt;% slice(-1) %&gt;% type_convert() toplot &lt;- raw %&gt;% select(site_id, village, edu_age_15up_total) %&gt;% arrange(desc(edu_age_15up_total)) %&gt;% mutate(index = row_number()) %&gt;% mutate(label = ifelse(index &lt;= 5 | index &gt; n()-5, paste0(site_id, village), &quot;&quot;)) library(ggrepel) p2 &lt;- toplot %&gt;% ggplot() + aes(index, edu_age_15up_total) + geom_point(alpha=0.5, color=&quot;royalblue&quot;) + geom_text_repel(aes(label = label), point.padding = .4, color = &quot;black&quot;, min.segment.length = 0, family = &quot;Heiti TC Light&quot;) + theme(axis.text.x=element_blank()) + scale_y_log10(breaks = c(0, 1, 10, 100, 1000, 10000)) + theme_minimal() p1 &lt;- toplot %&gt;% ggplot() + aes(index, edu_age_15up_total) + geom_point(alpha=0.5, color=&quot;royalblue&quot;) + theme(axis.text.x=element_blank()) + theme_minimal() cowplot::plot_grid( p2, NULL, p1, labels = c(&quot;a&quot;, &quot;&quot;, &quot;b&quot;), nrow = 1, rel_widths = c(1, 0.1, 1) ) 11.3 Square-root scale Chap3 Coordination &amp; Axis Fundamentals of Data Visualization (clauswilke.com) Figure 3.8: Areas of Northeastern U.S. states. (a) Areas shown on a linear scale. (b) Areas shown on a square-root scale. Data source: Google. 前面是視覺化了各村里大於十五歲以上人口的人口數分佈，採用對數尺度（log-scale）可以觀察到比較小的村里。那有什麼是適合用平方根尺度（sqrt-scale）的呢？是土地嗎？密度嗎？還是人口數？是村里等級嗎？鄉鎮市區等級嗎？還是縣市等級？ town &lt;- read_csv(&quot;data/tw_population_opendata110N010.csv&quot;) %&gt;% slice(-1, -(370:375)) %&gt;% type_convert() town %&gt;% arrange(desc(area)) %&gt;% mutate(index = row_number()) %&gt;% ggplot() + aes(index, area) %&gt;% geom_col(fill=&quot;skyblue&quot;) + scale_y_sqrt() + theme_minimal() Figure 11.1: (ref:population-area) county &lt;- town %&gt;% mutate(county = str_sub(site_id, 1, 3)) %&gt;% group_by(county) %&gt;% summarize( area = sum(area), people_total = sum(people_total) ) %&gt;% ungroup() p1 &lt;- county %&gt;% arrange(desc(people_total)) %&gt;% mutate(index = row_number()) %&gt;% ggplot() + aes(index, people_total) %&gt;% geom_col(fill=&quot;lightgrey&quot;) + # scale_y_sqrt() + theme_minimal() p2 &lt;- county %&gt;% arrange(desc(people_total)) %&gt;% mutate(index = row_number()) %&gt;% ggplot() + aes(index, people_total) %&gt;% geom_col(fill=&quot;khaki&quot;) + scale_y_sqrt(breaks=c(0, 250000, 500000, 1000000, 2000000, 4000000)) + theme_minimal() cowplot::plot_grid( p1, p2, labels = c(&quot;a&quot;, &quot;b&quot;), nrow = 1 ) Figure 11.2: (ref:population-area) library(tidyverse) library(gghighlight) 11.4 座標軸從數值到增加值 11.4.1 Net Worth by Age Group (WGOITG of NYTIMES) LEARNING NOTES Median for Inequality 這個教學案例來自紐約時報的「What’s going on in this gragh」系列資料視覺化教學之Teach About Inequality With These 28 New York Times Graphs - The New York Times (nytimes.com) 。該圖表呈現在不同年代、不同年齡層的人所擁有的淨資產（包含土地、存款、投資等減去債務）。該圖表的結果指出，在不同年代的老年人是越來越有錢，但年輕人卻越來越窮（該曲線為減去1989年 11.4.2 Read and sort data Sorted by arrange() function. p1 &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(year, Category, Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% ungroup() p1 %&gt;% filter(year &lt;= 1992) %&gt;% knitr::kable() year Category Net_Worth 1989 Less than 35 16.17019 1989 35-44 112.47530 1989 45-54 195.11630 1989 55-64 195.25554 1989 65-74 154.34277 1989 75 or older 144.29855 1992 Less than 35 16.60780 1992 35-44 79.91050 1992 45-54 139.97745 1992 55-64 203.44104 1992 65-74 176.44667 1992 75 or older 155.35173 p1 %&gt;% ggplot() + aes(year, Net_Worth, color = Category) + geom_line(linetype=&quot;dotted&quot;) + geom_point() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + theme_minimal() + scale_x_continuous(breaks = NULL) + theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;white&quot;, size = 0.5, linetype = &quot;solid&quot;)) p2 &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(year, Category, NW = Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% mutate(increase = (NW-first(NW))/first(NW)) %&gt;% ungroup() p2 %&gt;% filter(year &lt;= 1992) %&gt;% knitr::kable() year Category NW increase 1989 Less than 35 16.17019 0.0000000 1989 35-44 112.47530 0.0000000 1989 45-54 195.11630 0.0000000 1989 55-64 195.25554 0.0000000 1989 65-74 154.34277 0.0000000 1989 75 or older 144.29855 0.0000000 1992 Less than 35 16.60780 0.0270627 1992 35-44 79.91050 -0.2895285 1992 45-54 139.97745 -0.2825948 1992 55-64 203.44104 0.0419220 1992 65-74 176.44667 0.1432131 1992 75 or older 155.35173 0.0765994 p2 %&gt;% ggplot() + aes(year, increase, color = Category) + geom_line(linetype=&quot;dotted&quot;) + geom_point() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + theme_minimal() + scale_y_continuous(labels=scales::parse_format()) + scale_x_continuous(breaks = NULL) + theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;white&quot;, size = 0.5, linetype = &quot;solid&quot;)) 11.5 等比例座標軸 11.5.1 UNICEF-Optimistic (WGOITH) https://www.nytimes.com/2021/11/17/upshot/global-survey-optimism.html https://changingchildhood.unicef.org/about plot.opt &lt;- read_csv(&quot;nytdata/unicef-changing-childhood-data.csv&quot;) %&gt;% select(country = WP5, age = WP22140, bw = WP22092) %&gt;% mutate(country = ordered(country, levels=c(1, 3, 4, 10, 11, 12, 13, 14, 17, 29, 31, 33, 35, 36, 60, 61, 77, 79, 81, 87, 165), labels=c(&quot;USA&quot;, &quot;Morocco&quot;, &quot;Lebanon&quot;, &quot;Indonesia&quot;, &quot;Bangladesh&quot;, &quot;UK&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Spain&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;Brazil&quot;, &quot;Nigeria&quot;, &quot;Kenya&quot;, &quot;Ethiopia&quot;, &quot;Mali&quot;, &quot;Ukraine&quot;, &quot;Cameroon&quot;, &quot;Zimbabwe&quot;, &quot;Argentina&quot;, &quot;Peru&quot;))) %&gt;% count(country, age, bw) %&gt;% group_by(country, age) %&gt;% mutate(perc = n/sum(n)) %&gt;% ungroup() %&gt;% filter(bw == 1) %&gt;% select(country, age, perc) %&gt;% spread(age, perc) %&gt;% rename(`15-24y` = `1`, `40+y` = `2`) plot.opt %&gt;% head(10) %&gt;% knitr::kable() country 15-24y 40+y USA 0.6679842 0.4611465 Morocco 0.4365079 0.4735812 Lebanon 0.5467197 0.4435798 Indonesia 0.7920605 0.8027344 Bangladesh 0.4624506 0.4319527 UK 0.5040000 0.4140000 France 0.3900000 0.2640000 Germany 0.5900000 0.3860000 Spain 0.5160000 0.3340000 Japan 0.6367265 0.2586873 plot.opt %&gt;% ggplot() + aes(`40+y`, `15-24y`, label = country) + geom_point(color = &quot;skyblue&quot;, size = 2) + xlim(0, 1) + ylim(0,1) + geom_text(hjust = -0.1, vjust = -0.5) + geom_abline(intercept = 0, slop = 1, color=&quot;lightgrey&quot;, alpha=0.5, linetype=&quot;dashed&quot;) + theme_minimal() + theme(aspect.ratio=1) "],["amount.html", "Chapter 12 AMOUNT 12.1 Bar chart 12.2 Heatmap: Vaccination", " Chapter 12 AMOUNT 12.1 Bar chart 12.2 Heatmap: Vaccination 這個例子參考(Wilke 2019)在視覺化數量（Amount）時的熱圖範例（Heatmap），但改用為視覺化各國每百人完整注射COVID-19疫苗人數歷時資料。 - https://ourworldindata.org/covid-vaccinations - https://github.com/owid/covid-19-data/tree/master/public/data/vaccinations 這個案例使用了三個維度的資料，分別為X軸的時間（月）、Y軸的國家、以及用顏色來呈現各國疫苗注射量（每百人）。並使用geom_tile()來製作熱圖。然而，Y軸的排序卻會影響讀圖。例如，在第一個例子中，Y軸的順序是用最後一個時間點的疫苗注射比例來排序。但每個國家政策和疫苗可獲量均不同，故開始注射和覆蓋速度也差很多，最終覆蓋量也會差很多。所以如果以最終覆蓋量來排序的話，反而不易觀察過程的變化，且「顏色」並不容易用來比較最終覆蓋量的大小，因而會產生很多讀圖上的困擾。 另一種繪圖策略是該書上的做法，其Y軸的排序是依照疫苗覆蓋率達到某個數值（例如每百人中有20人完整注射二劑疫苗）的時間早晚來排序。有此作為基準，每個國家在後續時間點的覆蓋速度的比較便比較容易。 另外需要注意到，顏色的取捨、以及相對於尺度的漸層設計也會影響讀圖。 本例子的資料前處理難度較高（OS：惡魔級）。困難來自於每個國家登記資料的時間不同，因此會產生大量NA值。但在這樣的狀況下，又要找到以月為時間單位的共同數值，就會更挑戰程式編寫者的資料清理技術。除此之外，如何偵測「每個國家超過每百人有二十人完整注射疫苗的時間點」，更是技巧中的技巧。是個磨練NA值處理和高難度資料前處理的好例子。 library(lubridate) raw &lt;- read_csv(&quot;data/vaccinations.csv&quot;) fullvaccinated &lt;- raw %&gt;% select(country = location, date, people_fully_vaccinated_per_hundred) %&gt;% drop_na(people_fully_vaccinated_per_hundred) %&gt;% mutate(m = floor_date(date, unit = &quot;month&quot;)) %&gt;% group_by(country, m) %&gt;% arrange(date) %&gt;% slice(1) %&gt;% ungroup() %&gt;% select(-date) vperc_by_month &lt;- fullvaccinated %&gt;% spread(m, people_fully_vaccinated_per_hundred, fill=NA) %&gt;% gather(month, perc, -country) %&gt;% arrange(country, month) %&gt;% group_by(country) %&gt;% arrange(month) %&gt;% mutate(perc = zoo::na.locf(perc, na.rm = F)) %&gt;% ungroup() %&gt;% arrange(country, month) %&gt;% replace_na(list(perc=0)) https://clauswilke.com/dataviz/visualizing-amounts.html watched &lt;- c(&quot;United Arab Emirates&quot;, &quot;Japan&quot;, &quot;Singapore&quot;, &quot;South Korea&quot;, &quot;Taiwan&quot;, &quot;Malaysia&quot;, &quot;Hong Kong&quot;, &quot;New Zealand&quot;, &quot;Thailand&quot;, &quot;Netherlands&quot;, &quot;United States&quot;, &quot;Israel&quot;, &quot;United Kingdom&quot;, &quot;Indonesia&quot;, &quot;Thailand&quot;, &quot;Philippines&quot;) vperc_by_month %&gt;% spread(month, perc) %&gt;% filter(country %in% watched) %&gt;% mutate(country = reorder(country, -`2022-05-01`)) %&gt;% gather(month, perc, -country) %&gt;% ggplot() + aes(month, country, fill=perc) + geom_tile() + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) https://clauswilke.com/dataviz/visualizing-amounts.html vperc_by_month %&gt;% filter(country %in% watched) %&gt;% mutate(month = lubridate::as_date(month)) %&gt;% group_by(country) %&gt;% mutate(month1 = min((month[perc &gt; 20]))) %&gt;% ungroup() %&gt;% spread(month, perc) %&gt;% mutate(country = reorder(country, -as.numeric(month1))) %&gt;% select(-month1) %&gt;% gather(month, perc, -country) %&gt;% ggplot() + aes(month, country, fill=perc) + geom_tile() + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) References "],["distribution-histogram-density.html", "Chapter 13 DISTRIBUTION: Histogram &amp; Density 13.1 Density plot 13.2 Histogram 13.3 Pyramid Plot 13.4 Box plot: Muitiple Distrubution", " Chapter 13 DISTRIBUTION: Histogram &amp; Density Most of contet in the chapter comes from the book Claus o. Wilke’s “Foundamentals of Data Visualization” vilmaster &lt;- readr::read_csv(&quot;data/tw_vil2018_elccand.csv&quot;) %&gt;% drop_na(當選註記) 13.1 Density plot p1 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_density() + th p2 &lt;- vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_density(alpha=0.5) + th + scale_fill_manual( limits=c(&#39;1&#39;, &#39;2&#39;), # original chart group values=c(&quot;gold&quot;, &quot;skyblue&quot;), # map to color name=&quot;性別&quot;, # legend title breaks=c(1, 2), # original legend group labels labels=c(&quot;Male&quot;,&quot;Female&quot;), # map to new labels na.value = &quot;lightgrey&quot; # color for other groups ) cowplot::plot_grid( p1, p2, labels = c(&quot;(a) Overall&quot;, &quot;(b) Group by gender&quot;), nrow = 1, rel_widths = c(1, 1) ) 13.1.1 Density with different bandwidth library(ggridges) # for geom_density_line() p.b05 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_density_line(fill=&#39;gold&#39;, bw=0.5, kernel=&#39;gaussian&#39;) + th p.b1 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_density_line(fill=&#39;gold&#39;, bw=1, kernel=&#39;gaussian&#39;) + th p.b5 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_density_line(fill=&#39;gold&#39;, bw=5, kernel=&#39;gaussian&#39;) + th p.rect &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_density_line(fill=&#39;gold&#39;, bw=8, kernel=&#39;rectangular&#39;) + th cowplot::plot_grid( p.b05, p.b1, p.b5, p.rect, labels = c(&quot;(a) bw=.5&quot;, &quot;(b) bw=1&quot;, &quot;(c) bw=2&quot;, &quot;(b) rect&quot;), nrow = 2, rel_widths = c(1, 1) ) 13.2 Histogram 13.2.1 Histogram with different number of bins p10 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_histogram(bins=10, fill=&#39;royalblue&#39;) + th p20 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_histogram(bins=20, fill=&#39;royalblue&#39;) + th p30 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_histogram(bins=30, fill=&#39;royalblue&#39;) + th p40 &lt;- vilmaster %&gt;% ggplot() + aes(年齡) + geom_histogram(bins=40, fill=&#39;royalblue&#39;) + th cowplot::plot_grid( p10, p20, p30, p40, labels = c(&quot;(a) bins=10&quot;, &quot;(b) bins=20&quot;, &quot;(c) bins=30&quot;, &quot;(b) bins=40&quot;), nrow = 2, rel_widths = c(1, 1) ) 13.2.2 Density vs histogram pd &lt;- vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_density(alpha=0.5) + th + scale_fill_manual( values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue&quot;), labels=c(&#39;1&#39;=&quot;Male&quot;,&#39;2&#39;=&quot;Female&quot;), name=&#39;Sex&#39; ) ph &lt;- vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_histogram(bins=20, position=&quot;dodge&quot;) + th + scale_fill_manual(values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue &quot;)) + theme(legend.position=&quot;none&quot;) cowplot::plot_grid( pd, ph, labels = c(&quot;(a) geom_density()&quot;, &quot;(b) geom_histogram()&quot;), nrow = 1, rel_widths = c(6, 4) ) 13.2.3 Positions of bar chart p.hist.dodge &lt;- vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_histogram(bins=20, position=&quot;dodge&quot;) + th + scale_fill_manual( values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue &quot;), labels=c(&#39;1&#39;=&quot;Male&quot;,&#39;2&#39;=&quot;Female&quot;), name=&#39;Sex&#39; ) p.hist.stack &lt;- vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_histogram(bins=20, position=&quot;stack&quot;) + th + scale_fill_manual(values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue &quot;)) + theme(legend.position=&quot;none&quot;) cowplot::plot_grid( p.hist.dodge, p.hist.stack, labels = c(&quot;(a) position:dodge&quot;, &quot;(b) position:stack&quot;), nrow = 1, rel_widths = c(6, 4) ) 13.2.4 Display two groups histogram by facet_wrap() vilmaster %&gt;% ggplot() + aes(年齡, fill=factor(性別)) + geom_histogram(bins=20, position=&quot;dodge&quot;) + th + scale_fill_manual( values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue &quot;), labels=c(&#39;1&#39;=&quot;Male&quot;,&#39;2&#39;=&quot;Female&quot;), name=&#39;Sex&#39; ) + facet_wrap(.~性別, nrow=1) 13.3 Pyramid Plot 13.3.1 Modify geom_col() to pyramid plot vilmaster %&gt;% group_by(性別) %&gt;% mutate(age_group = cut(年齡, 0:20*5+.01)) %&gt;% count(age_group) %&gt;% ungroup() %&gt;% ggplot() + aes(x=age_group, y=ifelse(性別==&#39;1&#39;, -1, 1)*n, fill=factor(性別)) + geom_col() + scale_y_continuous(name = &quot;Count&quot;, breaks = 250*(-6:2), labels = c(&quot;1500&quot;, &quot;1250&quot;, &quot;1000&quot;, &quot;750&quot;, &quot;500&quot;, &quot;250&quot;, &quot;0&quot;, &quot;250&quot;, &quot;500&quot;)) + coord_flip() + scale_fill_manual( values=c(&quot;1&quot;=&#39;gold&#39;, &#39;2&#39;=&quot;skyblue &quot;), labels=c(&#39;1&#39;=&quot;Male&quot;,&#39;2&#39;=&quot;Female&quot;), name=&#39;Sex&#39; ) + th + labs(y=&quot;Count&quot;, x=&quot;Age Group&quot;) 13.4 Box plot: Muitiple Distrubution 13.4.1 TW-Salary (boxplot) Inspired by Six Myths About Choosing a College Major - The New York Times (nytimes.com) and What’s Going On in This Graph? | Jan. 9, 2018 - The New York Times (nytimes.com) library(readxl) raw &lt;- read_excel(&quot;data/tw_salary109.xlsx&quot;, sheet=1, trim_ws = T) raw Category Q1 Median Q3 Mean 男 39.0 53.2 82.3 70.7 女 35.1 46.8 67.6 58.6 未滿25歲 28.1 35.8 45.1 37.7 25-29歲 36.6 47.8 61.7 53.0 30-39歲 39.2 53.3 77.0 64.1 40-49歲 39.9 56.9 91.8 74.8 50-64歲 37.8 53.3 88.4 75.5 65歲以上 30.6 40.9 63.1 62.6 國中及以下 32.7 40.5 52.0 45.4 高中（職） 34.5 44.7 59.8 51.9 大專 38.6 53.7 80.2 67.0 研究所 60.9 96.0 139.3 116.4 礦業及土石採取業 34.2 57.2 91.7 68.5 製造業 38.7 50.4 73.2 64.8 電力及燃氣供應業 73.9 110.7 139.9 113.2 用水供應及污染整治業 31.9 45.7 63.9 54.6 營建工程業 34.1 46.1 64.0 54.7 批發及零售業 36.6 49.5 71.7 62.7 運輸及倉儲業 40.3 58.3 81.4 66.1 住宿及餐飲業 30.1 36.7 49.3 42.0 出版﹑影音製作﹑傳播及 資通訊服務業 53.0 71.5 111.2 88.8 金融及保險業 65.6 96.9 140.1 113.4 不動產業 36.8 52.2 76.6 65.0 專業科學及技術服務業 41.9 61.3 95.0 77.5 支援服務業 33.1 42.1 49.3 45.3 教育業-不含小學以上各級 學校 28.4 33.7 42.7 37.2 醫療保健及社會工作服務業 41.3 60.1 88.1 77.1 藝術娛樂及休閒服務業 28.8 39.2 57.2 48.8 其他服務業 30.6 35.8 49.1 43.6 raw %&gt;% slice(-(1:12)) %&gt;% mutate(Category = reorder(Category, desc(Median))) %&gt;% ggplot() + aes(y = Category, xlower=Q1, xmiddle=Median, xupper=Q3, xmin=0, xmax=150) + geom_boxplot(stat = &quot;identity&quot;, color=&quot;white&quot;, fill=&quot;skyblue&quot;) + geom_point(aes(x = Mean)) + th + theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) 13.4.2 TW-Income (boxplot) library(gghighlight) toplot &lt;- read_csv(&quot;data/tw_income_107.csv&quot;, ) %&gt;% filter(!`村里` %in% c(&quot;合計&quot;, &quot;其他&quot;, &quot;福住里&quot;)) %&gt;% filter(鄉鎮市區 %in% c(&quot;信義區&quot;)) %&gt;% mutate(村里 = reorder(村里, desc(中位數))) toplot %&gt;% mutate(group = if_else((平均數&gt;第三分位數), &quot;highlight&quot;, &quot;none&quot;)) %&gt;% ggplot() + aes(y = 村里, xlower=第一分位數, xmiddle=中位數, xupper=第三分位數, xmin= min(第一分位數), xmax=max(第三分位數), fill=group) + geom_boxplot(stat = &quot;identity&quot;, color=&quot;white&quot;) + scale_fill_manual(values = c(&quot;highlight&quot;=&quot;orangered&quot;, &quot;none&quot;=&quot;skyblue&quot;)) + guides(fill=FALSE) + geom_point(aes(x = 平均數)) + xlab(&quot;年所得（單位：千元）&quot;) + th + theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) "],["proportion.html", "Chapter 14 PROPORTION 14.1 Pie Chart 14.2 Dodged Bar Chart 14.3 Treemap: Nested Proportion", " Chapter 14 PROPORTION 14.1 Pie Chart 14.2 Dodged Bar Chart 14.3 Treemap: Nested Proportion 14.3.1 Global Carbon Projects (WGOITH-NYTIMES) Who Has The Most Historical Responsibility for Climate Change? - The New York Times (nytimes.com) totreemap &lt;- read_csv(&quot;nytdata/GCB2021v34_MtCO2_flat.csv&quot;) %&gt;% drop_na(`Total`) %&gt;% filter(!Country %in% c(&quot;Global&quot;, &quot;International Transport&quot;)) %&gt;% filter(Year==2020) %&gt;% arrange(desc(`Total`)) %&gt;% mutate(perc = Total/sum(Total)) %&gt;% slice(1:20) library(treemapify) totreemap %&gt;% ggplot() + aes(area = perc, fill=`Per Capita`, label=Country) + geom_treemap() + geom_treemap_text(color=&quot;white&quot;, place=&quot;centre&quot;, grow=TRUE ) 14.3.2 TW Budget library(zoo) # raw &lt;- readxl::read_excel(&quot;data/111B歲出政事別預算總表.xls&quot;) raw &lt;- readxl::read_excel(&quot;data/111B歲出政事別預算表.xls&quot;, skip=3, col_names = F) names(raw) &lt;- c(&quot;款&quot;, &quot;科&quot;, &quot;目&quot;, &quot;節&quot;, &quot;機構&quot;, &quot;本年度預算&quot;, &quot;上年度預算&quot;, &quot;上年度決算&quot;, &quot;預算差&quot;) # raw$款 &lt;- na.locf(raw$款) cleand &lt;- raw %&gt;% filter(!is.na(款) | !is.na(科)) %&gt;% slice(-(1:2)) %&gt;% select(-目, -節) %&gt;% mutate(org = purrr::map(機構, function(x){str_split(x, &quot;\\n&quot;)[[1]][2]})) %&gt;% mutate(款 = ifelse(!is.na(款), unlist(org), unlist(款))) %&gt;% mutate(款 = zoo::na.locf(款)) %&gt;% filter(!is.na(科)) %&gt;% select(-科) %&gt;% type_convert() %&gt;% mutate(上年度預算 = as.numeric(上年度預算), 上年度決算 = as.integer(上年度決算), 預算差 = as.numeric(預算差)) %&gt;% replace_na(list(上年度預算 = 0, 上年度決算 = 0)) %&gt;% mutate(預算差 = 本年度預算 - 上年度預算) cleand %&gt;% filter(款 %in% c(&quot;科學支出&quot;)) %&gt;% ggplot() + aes(area = 本年度預算, fill=`本年度預算`, label=org) + geom_treemap() + geom_treemap_text(color=&quot;white&quot;, place=&quot;centre&quot;, grow=TRUE, family = &quot;Heiti TC Light&quot; ) + theme(title = element_text(family = &quot;Heiti TC Light&quot;), text = element_text(family = &quot;Heiti TC Light&quot;)) library(treemapify) cleand %&gt;% # filter(款 %in% c(&quot;科學支出&quot;, &quot;教育支出&quot;, &quot;國防支出&quot;, &quot;司法支出&quot;)) %&gt;% ggplot() + aes(area = 本年度預算, fill=`本年度預算`, label=org, subgroup = 款) + geom_treemap() + geom_treemap_subgroup_border(color=&quot;gold&quot;) + geom_treemap_subgroup_text(place = &quot;centre&quot;, grow = T, alpha = 0.5, colour = &quot;gold&quot;, min.size = 0, family = &quot;Heiti TC Light&quot;) + geom_treemap_text(color=&quot;white&quot;, place=&quot;centre&quot;, grow=F, family = &quot;Heiti TC Light&quot; ) + theme(title = element_text(family = &quot;Heiti TC Light&quot;), text = element_text(family = &quot;Heiti TC Light&quot;), legend.position = &quot;none&quot;) "],["association.html", "Chapter 15 ASSOCIATION 15.1 等比例座標軸", " Chapter 15 ASSOCIATION 15.1 等比例座標軸 15.1.1 UNICEF-Optimistic (WGOITH) https://www.nytimes.com/2021/11/17/upshot/global-survey-optimism.html https://changingchildhood.unicef.org/about plot.opt &lt;- read_csv(&quot;nytdata/unicef-changing-childhood-data.csv&quot;) %&gt;% select(country = WP5, age = WP22140, bw = WP22092) %&gt;% mutate(country = ordered(country, levels=c(1, 3, 4, 10, 11, 12, 13, 14, 17, 29, 31, 33, 35, 36, 60, 61, 77, 79, 81, 87, 165), labels=c(&quot;USA&quot;, &quot;Morocco&quot;, &quot;Lebanon&quot;, &quot;Indonesia&quot;, &quot;Bangladesh&quot;, &quot;UK&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Spain&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;Brazil&quot;, &quot;Nigeria&quot;, &quot;Kenya&quot;, &quot;Ethiopia&quot;, &quot;Mali&quot;, &quot;Ukraine&quot;, &quot;Cameroon&quot;, &quot;Zimbabwe&quot;, &quot;Argentina&quot;, &quot;Peru&quot;))) %&gt;% count(country, age, bw) %&gt;% group_by(country, age) %&gt;% mutate(perc = n/sum(n)) %&gt;% ungroup() %&gt;% filter(bw == 1) %&gt;% select(country, age, perc) %&gt;% spread(age, perc) %&gt;% rename(`15-24y` = `1`, `40+y` = `2`) plot.opt %&gt;% head(10) %&gt;% knitr::kable() country 15-24y 40+y USA 0.6679842 0.4611465 Morocco 0.4365079 0.4735812 Lebanon 0.5467197 0.4435798 Indonesia 0.7920605 0.8027344 Bangladesh 0.4624506 0.4319527 UK 0.5040000 0.4140000 France 0.3900000 0.2640000 Germany 0.5900000 0.3860000 Spain 0.5160000 0.3340000 Japan 0.6367265 0.2586873 plot.opt %&gt;% ggplot() + aes(`40+y`, `15-24y`, label = country) + geom_point(color = &quot;skyblue&quot;, size = 2) + xlim(0, 1) + ylim(0,1) + geom_text(hjust = -0.1, vjust = -0.5) + geom_abline(intercept = 0, slop = 1, color=&quot;lightgrey&quot;, alpha=0.5, linetype=&quot;dashed&quot;) + theme_minimal() + theme(aspect.ratio=1) "],["time-trends.html", "Chapter 16 TIME &amp; TRENDS", " Chapter 16 TIME &amp; TRENDS "],["network-vis.html", "Chapter 17 NETWORK VIS 17.1 Generating networks 17.2 Retrieve Top3 Components 17.3 Motif visualization and analysis", " Chapter 17 NETWORK VIS 網絡視覺化其實已經有非常好的簡介和指南。但在此補充一些常用的網絡視覺化參數 library(igraph) 17.1 Generating networks 17.1.1 Random network g &lt;- barabasi.game(500, directed = T) message(&quot;\\n(V, E, Reciprocity, nComponent)\\n&quot;, length(V(g)), &quot;\\t&quot;, length(E(g)), &quot;\\t&quot;, sprintf(&quot;%.3f\\t&quot;, reciprocity(g)), count_components(g, mode = &quot;weak&quot;) ) l &lt;- layout.fruchterman.reingold(g) # l &lt;- layout_with_kk(g) # l &lt;- layout_in_circle(g) par(mar = c(0,0,0,0) + 0.1) plot(g, layout = l, vertex.color = rgb(1, 1, 0, 0.2), # vertex.color = factor(V(g)$blocked), vertex.size = 3, # vertex.size = sqrt(V(g)$degree)*3, vertex.frame.color= rgb(0, 0, 0, 0.5), # vertex.label = V(g)$display, # vertex.label = str_sub(V(g)$name, 1, 10), vertex.label.cex = 0.6, vertex.label.color = rgb(0, 0, 0, 0.7), vertex.label.family = &#39;Heiti TC Light&#39;, edge.curved = 0.1, edge.arrow.size = 0.1, # edge.width = sqrt(E(g)$weight), # edge.color = E(g)$year, # edge.color = E(g)$weight, edge.color = &quot;#4169E1&quot;, # edge.color = E(g)$color, # edge.label = E(g)$weight, # edge.label = E(g)$year, edge.label.cex = 0.4, edge.label.color = rgb(1, 0, 0) ) 17.1.2 Random network rg &lt;- sample_gnm(length(V(g)), length(E(g)), directed=T) message(&quot;\\n(V, E, Reciprocity, nComponent)\\n&quot;, length(V(rg)), &quot;\\t&quot;, length(E(rg)), &quot;\\t&quot;, sprintf(&quot;%.3f\\t&quot;, reciprocity(rg)), count_components(rg, mode = &quot;weak&quot;) ) l &lt;- layout.fruchterman.reingold(rg) par(mar = c(0,0,0,0) + 0.1) plot(rg, layout = l, vertex.color = rgb(1, 1, 0, 0.2), vertex.size = 3, vertex.frame.color= rgb(0, 0, 0, 0.5), vertex.label.cex = 0.6, vertex.label.color = rgb(0, 0, 0, 0.7), vertex.label.family = &#39;Heiti TC Light&#39;, edge.curved = 0.1, edge.arrow.size = 0.1, edge.color = &quot;#4169E1&quot;, edge.label.cex = 0.4, edge.label.color = rgb(1, 0, 0) ) 17.2 Retrieve Top3 Components components &lt;- igraph::clusters(rg, mode=&quot;weak&quot;) biggest_cluster_id &lt;- which.max(components$csize) # which.max(components$csize) # components$csize # biggest_cluster_id top3_break &lt;- sort(unique(components$csize), decreasing = T)[3] biggest_cluster_id &lt;- which(components$csize &gt;= top3_break) vert_ids &lt;- V(rg)[components$membership %in% biggest_cluster_id] rg &lt;- igraph::induced_subgraph(rg, vert_ids) message(&quot;\\n(V, E, Reciprocity, nComponent)\\n&quot;, length(V(rg)), &quot;\\t&quot;, length(E(rg)), &quot;\\t&quot;, sprintf(&quot;%.3f&quot;, reciprocity(rg)) ) 17.2.1 Visualize again l &lt;- layout.fruchterman.reingold(rg) par(mar = c(0,0,0,0) + 0.1) plot(rg, layout = l, vertex.color = rgb(1, 1, 0, 0.2), vertex.size = 3, vertex.frame.color= rgb(0, 0, 0, 0.5), vertex.label.cex = 0.6, vertex.label.color = rgb(0, 0, 0, 0.7), vertex.label.family = &#39;Heiti TC Light&#39;, edge.curved = 0.1, edge.arrow.size = 0.1, edge.color = &quot;#4169E1&quot;, edge.label.cex = 0.4, edge.label.color = rgb(1, 0, 0) ) 17.3 Motif visualization and analysis 17.3.1 Motif type library(igraph) par(mfrow=c(4,4), mai= rep(0.2, 4)) for(i in 0:15){ g1 &lt;- graph_from_isomorphism_class(3, i) plot(g1, vertex.color = &quot;gold&quot;, vertex.size = 20, # vertex.size = (V(g)$nTweets)^(1/3)+1, vertex.frame.color= &quot;black&quot;, vertex.label = NA, edge.color = &quot;black&quot;, edge.arrow.size = 0.5) title(i, line=-3, adj=0.4 ,col.main=&quot;royalblue&quot;) } 17.3.2 Motif analysis 17.3.2.1 Generate network res &lt;- motifs(g, 3) res ## [1] NA NA 2236 NA 483 0 0 0 0 0 0 0 0 0 0 ## [16] 0 writeLines(as.character(res), sep = &quot;\\t&quot;) ## NA NA 2236 NA 483 0 0 0 0 0 0 0 0 0 0 0 17.3.3 Generate motives barabas_motif &lt;- function(e){ g &lt;- barabasi.game(e, directed = T) vec &lt;- motifs(g, 3) %&gt;% replace_na(0) for(i in 1:99){ g &lt;- barabasi.game(e, directed = T) tmp &lt;- motifs(g, 3) %&gt;% replace_na(0) vec &lt;- vec + tmp } vec &lt;- vec / 100 writeLines(as.character(vec), sep = &quot;\\t&quot;) } random_net_motif &lt;- function(v, e){ g &lt;- sample_gnm(v, e, directed=T) vec &lt;- motifs(g, 3) %&gt;% replace_na(0) for(i in 1:99){ g &lt;- sample_gnm(v, e, directed=T) tmp &lt;- motifs(g, 3) %&gt;% replace_na(0) vec &lt;- vec + tmp } vec &lt;- vec / 100 writeLines(as.character(vec), sep = &quot;\\t&quot;) } random_net_motif(length(V(g)), length(E(g))) ## 0 0 243.68 0 494.25 0.7 245.38 0.87 0 0.89 0 0.34 0.01 0 0 0 barabas_motif(length(E(g))) ## 0 0 2486.49 0 463.18 0 0 0 0 0 0 0 0 0 0 0 "],["geospatial.html", "Chapter 18 GEOSPATIAL", " Chapter 18 GEOSPATIAL "],["interactivity.html", "Chapter 19 Interactivity 19.1 ggplotly 19.2 產製圖表動畫", " Chapter 19 Interactivity 19.1 ggplotly Scatter plots with ggplot2 (plotly.com) 19.1.1 LINE CHART Line plots with R (plotly.com) NW &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(Category, year, Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% ungroup() 如果希望滑鼠在移到折線上時就會有浮出的資訊（tips）顯示該資料點的屬性特徵，可以採用plotly()這個套件。這個套件原本就是做線上互動圖表的，但他開發了R client讓R的使用者可以很輕易地把ggplot2的結果轉為互動圖表。但這所謂的互動也僅限於滑鼠移過去所浮出的資訊罷了，不過已經能夠達到吸引部分讀者目光、提供訊息的效果。 而plotly的設計非常簡單，就是把ggplot的結果指給一個變數後，然後用ggplotly(NW.plot)將其轉為plotly即可。但要注意的是，並不是每一個圖都可以順利轉換。例如本節最後一個例子Treemap便無法成功轉換。 設定：原本plotly會帶一個操控列，可以在ggplotly()指令後加入config()便可將其隱藏。 NW.plot &lt;- NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category) + geom_line() + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) + th library(plotly) ggplotly(NW.plot) %&gt;% config(displayModeBar = FALSE) 可以在aes()設定要帶入圖的變數時，新增一個text變數，手動設定要呈現的動態呈現方塊。但要注意的是，要多加入一個group=1才能夠作用（WHY？）。但前例浮出視窗的原始內容所顯示的是原本的變數名稱和值，往往不易觀察。比較好的方式是在下ggplot() + aes()指令時，在aes()中指定text來作為後續浮出視窗內容。指定方法如下。要注意的是，該浮出視窗的語法是HTML，所以如果要改寫浮出視窗內容，要用paste0()將變數和HTML的標籤給銜接起來。以下例子中的&lt;b&gt;代表粗體的意思，&lt;br&gt;則是換行符號。 NW.plot &lt;- NW %&gt;% ggplot() + aes(year, Net_Worth, color=Category, text = paste0(&quot;&lt;b&gt;年(X): &lt;/b&gt;&quot;, year, &quot;&lt;br&gt;&quot;, &quot;&lt;b&gt;淨資產(Y): &lt;/b&gt;&quot;, Net_Worth,&quot;&lt;br&gt;&quot;, &quot;&lt;b&gt;年齡組: &lt;/b&gt;&quot;, Category), group=1) + geom_line() + theme_minimal() + labs(title = &quot;Net Worth by year grouped by age groups&quot;, x = &quot;Year&quot;, y = &quot;Net Worth&quot;) + th ggplotly(NW.plot, tooltip = &quot;text&quot;) %&gt;% config(displayModeBar = FALSE) 其他例子中使用ggplotly()都是直接照前面的方法套用即可。唯獨在Treemap中無法用這樣的方法來做互動的視覺化。想想這也正常，畢竟Treemap是用非ggplot的第三方套件（library(treemapify)）。 除此之外，可以把R Markdown中Code Cell的的設定加入include=FALSE，這樣可以讓RMD在編製為HTML檔時，不要顯示程式碼，而直接顯示互動的視覺化介面。 19.1.2 SCATTER bw &lt;- read_csv(&quot;nytdata/unicef-changing-childhood-data.csv&quot;) %&gt;% select(country = WP5, age = WP22140, bw = WP22092) %&gt;% mutate(country = ordered(country, levels=c(1, 3, 4, 10, 11, 12, 13, 14, 17, 29, 31, 33, 35, 36, 60, 61, 77, 79, 81, 87, 165), labels=c(&quot;USA&quot;, &quot;Morocco&quot;, &quot;Lebanon&quot;, &quot;Indonesia&quot;,&quot;Bangladesh&quot;, &quot;UK&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Spain&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;Brazil&quot;, &quot;Nigeria&quot;, &quot;Kenya&quot;, &quot;Ethiopia&quot;, &quot;Mali&quot;, &quot;Ukraine&quot;, &quot;Cameroon&quot;, &quot;Zimbabwe&quot;,&quot;Argentina&quot;, &quot;Peru&quot;))) %&gt;% count(country, age, bw) %&gt;% group_by(country, age) %&gt;% mutate(perc = n/sum(n)) %&gt;% ungroup() %&gt;% filter(bw == 1) %&gt;% select(country, age, perc) %&gt;% spread(age, perc) %&gt;% rename(`15-24y` = `1`, `40+y` = `2`) bw.p &lt;- bw %&gt;% ggplot() + aes(`40+y`, `15-24y`, label = country) + geom_point(color = &quot;skyblue&quot;, size = 2) + xlim(0.2, 0.85) + ylim(0.2, 0.85) + geom_text(hjust = -0.1, vjust = -0.5) + geom_abline(intercept = 0, slop = 1, color=&quot;lightgrey&quot;, alpha=0.5, linetype=&quot;dashed&quot;) + th + theme(aspect.ratio=1) bw.p %&gt;% ggplotly() 19.1.3 Barplot Bar charts with R (plotly.com) county &lt;- read_csv(&quot;data/tw_population_opendata110N010.csv&quot;) %&gt;% slice(-1, -(370:375)) %&gt;% type_convert() %&gt;% mutate(county = str_sub(site_id, 1, 3)) %&gt;% group_by(county) %&gt;% summarize( area = sum(area), people_total = sum(people_total) ) %&gt;% ungroup() population.p &lt;- county %&gt;% mutate(county = reorder(county, people_total)) %&gt;% ggplot() + aes(county, people_total) %&gt;% geom_col(fill=&quot;skyblue&quot;) + coord_flip() + th population.p %&gt;% ggplotly() 19.1.4 Boxplot Box plots with ggplot2 (plotly.com) aqi.toplot &lt;- read_rds(&quot;https://github.com/p4css/R4CSS/raw/master/data/AQI_Chaozhou.rds&quot;) %&gt;% arrange(日期)%&gt;% filter(測項==&quot;PM2.5&quot;) %&gt;% gather(&quot;hour&quot;, &quot;PM25&quot;, 4:28) %&gt;% mutate(PM25 = as.numeric(PM25)) %&gt;% drop_na() %&gt;% mutate(year = lubridate::year(日期), month = lubridate::month(日期)) %&gt;% filter(month %in% c(11, 12, 1, 2, 3)) aqi.plot &lt;- aqi.toplot %&gt;% mutate(year = as.character(year)) %&gt;% ggplot() + aes(x=year, y=PM25) + geom_boxplot(fill=&quot;skyblue&quot;, alpha=0.2) + ylim(0, 200) + coord_flip() + theme_minimal() aqi.plot %&gt;% ggplotly 19.1.5 Treemap (Global Carbon) 其他例子中使用ggplotly()都是直接照前面的方法套用即可。唯獨在Treemap中無法用這樣的方法來做互動的視覺化。想想這也正常，畢竟Treemap是用非ggplot的第三方套件（library(treemapify)）。 totreemap &lt;- read_csv(&quot;nytdata/GCB2021v34_MtCO2_flat.csv&quot;) %&gt;% drop_na(`Total`) %&gt;% filter(!Country %in% c(&quot;Global&quot;, &quot;International Transport&quot;)) %&gt;% filter(Year==2020) %&gt;% arrange(desc(`Total`)) %&gt;% mutate(perc = Total/sum(Total)) %&gt;% slice(1:20) library(treemapify) carbon.p &lt;- totreemap %&gt;% ggplot() + aes(area = perc, fill=`Per Capita`, label=Country) + geom_treemap() + geom_treemap_text(color=&quot;white&quot;, place=&quot;centre&quot;, grow=TRUE ) # carbon.p %&gt;% ggplotly 19.2 產製圖表動畫 https://gist.github.com/rafapereirabr/0d68f7ccfc3af1680c4c8353cf9ab345 R也有套工具可以產製圖表動畫，概念上就是沿著一條資料維度，把多張圖給疊在一起變成一個gif動畫。本例子即是把產假之薪的範例沿著時間軸做動畫。每個時間點都是當年各國產假支薪給付程度的地圖，但由於有19年的資料，所以可以把年代當成動畫的時間軸。 以下是清理資料的步驟，會彙整出國名、國家代碼（ISO3）、年、和給付等級四個變項。預期利用國名、國家代碼和給付等級就可以畫出每年的圖。然後將年作為動畫的時間軸，便可產生地圖動畫。 pml &lt;- read_excel(&quot;data/WORLD-MACHE_Gender_6.8.15.xls&quot;, &quot;Sheet1&quot;, col_names=T) %&gt;% select(country, iso3, contains(&quot;matleave&quot;), -contains(&quot;wrr&quot;)) %&gt;% gather(&quot;year&quot;, &quot;degree&quot;, 3:21) %&gt;% replace_na(list(degree=0)) %&gt;% mutate(year2=as.POSIXct(strptime(year, &quot;matleave_%y&quot;))) %&gt;% mutate(year3 = strftime(year2, &quot;%Y&quot;)) %&gt;% select(country, ISO3=iso3, year=year3, degree) 19.2.1 地圖下載與轉換投影方法 此為下載地圖並處理地圖成為可以用geom_polygom()繪圖的多邊形資料點。 library(rworldmap) wmap &lt;- getMap(resolution=&quot;low&quot;) wmap &lt;- spTransform(wmap, CRS(&quot;+proj=robin&quot;)) # reproject wmap &lt;- fortify(wmap) wmap %&gt;% filter(!duplicated(id)) %&gt;% head(10) long lat order hole piece id group -6558139.1 1331766 1 FALSE 1 Aruba Aruba.1 6607120.5 3981588 1 FALSE 1 Afghanistan Afghanistan.1 1338236.2 -628452 1 FALSE 1 Angola Angola.1 -5863722.7 1948852 1 FALSE 1 Anguilla Anguilla.1 1723246.7 4546404 1 FALSE 1 Albania Albania.1 1503172.1 6370384 1 FALSE 1 Aland Aland.1 146562.7 4541753 1 FALSE 1 Andorra Andorra.1 5157180.1 2742768 1 FALSE 1 United Arab Emirates United Arab Emirates.1 -6080937.4 -2363597 1 FALSE 1 Argentina Argentina.1 3901101.2 4403251 1 FALSE 1 Armenia Armenia.1 pml_map &lt;- wmap %&gt;% left_join(pml, by=c(&quot;id&quot;=&quot;country&quot;)) %&gt;% filter(!is.na(ISO3)) %&gt;% mutate(year = as.integer(year)) # devtools::install_github(&quot;thomasp85/transformr&quot;) pml_map %&gt;% select(id) %&gt;% filter(!duplicated(.)) %&gt;% head(10) id Afghanistan Angola Albania Andorra United Arab Emirates Argentina Armenia Antigua and Barbuda Australia Austria 19.2.2 靜態繪圖測試 pml_map %&gt;% filter(year==1995) %&gt;% ggplot() + aes(x = long, y = lat, group=group, fill=factor(degree)) + geom_polygon(color=&quot;grey&quot;) + theme_void() + scale_fill_manual(values=c(&quot;1&quot;=&quot;red&quot;, &quot;2&quot;=&quot;LightCyan&quot;, &quot;3&quot;=&quot;lightskyblue&quot;, &quot;4&quot;=&quot;DodgerBlue&quot;, &quot;5&quot;=&quot;MediumBlue&quot;)) + coord_cartesian(xlim = c(-11807982, 14807978)) 在採用gganimate繪圖時，僅需要多加一個動畫繪圖函式+ transition_time(year)即可，其他繪圖部分並無修改。最後才用animate()函式把這整個繪圖指令轉製為動畫，包含指定fps（frame per second）和長寬等參數。 library(gganimate) pml.ani &lt;- pml_map %&gt;% ggplot() + aes(x = long, y = lat, group=group, fill=factor(degree)) + geom_polygon(color=&quot;grey&quot;) + theme_void() + scale_fill_manual(values=c(&quot;1&quot;=&quot;red&quot;, &quot;2&quot;=&quot;LightCyan&quot;, &quot;3&quot;=&quot;lightskyblue&quot;, &quot;4&quot;=&quot;DodgerBlue&quot;, &quot;5&quot;=&quot;MediumBlue&quot;)) + coord_cartesian(xlim = c(-11807982, 14807978)) + transition_time(year) # + # ease_aes(&quot;linear&quot;) + # enter_fade() + # exit_fade() animate(pml.ani, fps = 10, end_pause = 30, width = 750, height = 450, renderer = gifski_renderer()) anim_save(&quot;jour5014/pml2.gif&quot;, animation = last_animation()) knitr::include_graphics(&quot;jour5014/pml2.gif&quot;) "],["appendix.html", "Chapter 20 Appendix 20.1 Dataset", " Chapter 20 Appendix 20.1 Dataset 111B歲出政事別預算表.xls - 111B歲出政事別預算總表.xls 臺北市住宅竊盜點位資訊-UTF8-BOM-1.csv opendata107Y020.csv opendata110Y060.csv tptheft.csv tw_income_107.csv tw_population_opendata110N010.csv tw_salary109.xlsx villmast_excel.xls WORLD-MACHE_Gender_6.8.15.xls "],["wgoitg.html", "Chapter 21 WGOITG of NyTimes 21.1 Inequality: Net Worth by Age Group 21.2 UNICEF-Global Survey Optimism 21.3 Global Carbon Projects", " Chapter 21 WGOITG of NyTimes library(tidyverse) library(gghighlight) 21.1 Inequality: Net Worth by Age Group LEARNING NOTES 座標軸從數值到增加值 這個教學案例來自紐約時報的「What’s going on in this gragh」系列資料視覺化教學之Teach About Inequality With These 28 New York Times Graphs - The New York Times (nytimes.com) 。該圖表呈現在不同年代、不同年齡層的人所擁有的淨資產（包含土地、存款、投資等減去債務）。該圖表的結果指出，在不同年代的老年人是越來越有錢，但年輕人卻越來越窮（該曲線為減去1989年 Sorted by arrange() function. p1 &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(year, Category, Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% ungroup() p1 %&gt;% filter(year &lt;= 1992) %&gt;% knitr::kable() year Category Net_Worth 1989 Less than 35 16.17019 1989 35-44 112.47530 1989 45-54 195.11630 1989 55-64 195.25554 1989 65-74 154.34277 1989 75 or older 144.29855 1992 Less than 35 16.60780 1992 35-44 79.91050 1992 45-54 139.97745 1992 55-64 203.44104 1992 65-74 176.44667 1992 75 or older 155.35173 p1 %&gt;% ggplot() + aes(year, Net_Worth, color = Category) + geom_line(linetype=&quot;dotted&quot;) + geom_point() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + theme_minimal() + scale_x_continuous(breaks = NULL) + theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;white&quot;, size = 0.5, linetype = &quot;solid&quot;)) p2 &lt;- read_csv(&quot;nytdata/interactive_bulletin_charts_agecl_median.csv&quot;) %&gt;% select(year, Category, NW = Net_Worth) %&gt;% group_by(Category) %&gt;% arrange(year) %&gt;% mutate(increase = (NW-first(NW))/first(NW)) %&gt;% ungroup() p2 %&gt;% filter(year &lt;= 1992) %&gt;% knitr::kable() year Category NW increase 1989 Less than 35 16.17019 0.0000000 1989 35-44 112.47530 0.0000000 1989 45-54 195.11630 0.0000000 1989 55-64 195.25554 0.0000000 1989 65-74 154.34277 0.0000000 1989 75 or older 144.29855 0.0000000 1992 Less than 35 16.60780 0.0270627 1992 35-44 79.91050 -0.2895285 1992 45-54 139.97745 -0.2825948 1992 55-64 203.44104 0.0419220 1992 65-74 176.44667 0.1432131 1992 75 or older 155.35173 0.0765994 p2 %&gt;% ggplot() + aes(year, increase, color = Category) + geom_line(linetype=&quot;dotted&quot;) + geom_point() + gghighlight(Category %in% c(&quot;65-74&quot;, &quot;35-44&quot;)) + theme_minimal() + scale_y_continuous(labels=scales::parse_format()) + scale_x_continuous(breaks = NULL) + theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;white&quot;, size = 0.5, linetype = &quot;solid&quot;)) 21.2 UNICEF-Global Survey Optimism 運用等比例之座標軸 https://www.nytimes.com/2021/11/17/upshot/global-survey-optimism.html https://changingchildhood.unicef.org/about plot.opt &lt;- read_csv(&quot;nytdata/unicef-changing-childhood-data.csv&quot;) %&gt;% select(country = WP5, age = WP22140, bw = WP22092) %&gt;% mutate(country = ordered(country, levels=c(1, 3, 4, 10, 11, 12, 13, 14, 17, 29, 31, 33, 35, 36, 60, 61, 77, 79, 81, 87, 165), labels=c(&quot;USA&quot;, &quot;Morocco&quot;, &quot;Lebanon&quot;, &quot;Indonesia&quot;, &quot;Bangladesh&quot;, &quot;UK&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Spain&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;Brazil&quot;, &quot;Nigeria&quot;, &quot;Kenya&quot;, &quot;Ethiopia&quot;, &quot;Mali&quot;, &quot;Ukraine&quot;, &quot;Cameroon&quot;, &quot;Zimbabwe&quot;, &quot;Argentina&quot;, &quot;Peru&quot;))) %&gt;% count(country, age, bw) %&gt;% group_by(country, age) %&gt;% mutate(perc = n/sum(n)) %&gt;% ungroup() %&gt;% filter(bw == 1) %&gt;% select(country, age, perc) %&gt;% spread(age, perc) %&gt;% rename(`15-24y` = `1`, `40+y` = `2`) plot.opt %&gt;% head(10) %&gt;% knitr::kable() country 15-24y 40+y USA 0.6679842 0.4611465 Morocco 0.4365079 0.4735812 Lebanon 0.5467197 0.4435798 Indonesia 0.7920605 0.8027344 Bangladesh 0.4624506 0.4319527 UK 0.5040000 0.4140000 France 0.3900000 0.2640000 Germany 0.5900000 0.3860000 Spain 0.5160000 0.3340000 Japan 0.6367265 0.2586873 plot.opt %&gt;% ggplot() + aes(`40+y`, `15-24y`, label = country) + geom_point(color = &quot;skyblue&quot;, size = 2) + xlim(0, 1) + ylim(0,1) + geom_text(hjust = -0.1, vjust = -0.5) + geom_abline(intercept = 0, slop = 1, color=&quot;lightgrey&quot;, alpha=0.5, linetype=&quot;dashed&quot;) + theme_minimal() + theme(aspect.ratio=1) 21.3 Global Carbon Projects Who Has The Most Historical Responsibility for Climate Change? - The New York Times (nytimes.com) totreemap &lt;- read_csv(&quot;nytdata/GCB2021v34_MtCO2_flat.csv&quot;) %&gt;% drop_na(`Total`) %&gt;% filter(!Country %in% c(&quot;Global&quot;, &quot;International Transport&quot;)) %&gt;% filter(Year==2020) %&gt;% arrange(desc(`Total`)) %&gt;% mutate(perc = Total/sum(Total)) %&gt;% slice(1:20) library(treemapify) totreemap %&gt;% ggplot() + aes(area = perc, fill=`Per Capita`, label=Country) + geom_treemap() + geom_treemap_text(color=&quot;white&quot;, place=&quot;centre&quot;, grow=TRUE ) "],["taiwan.html", "Chapter 22 Case Studies (Taiwan) 22.1 TW AQI Visual Studies", " Chapter 22 Case Studies (Taiwan) 22.1 TW AQI Visual Studies library(tidyverse) library(readxl) # options(stringsAsFactors = F) aqi_data &lt;- read_rds(&quot;https://github.com/p4css/R4CSS/raw/master/data/AQI_Chaozhou.rds&quot;) 22.1.1 Trending: Central tendency toplot &lt;- aqi_data %&gt;% arrange(日期)%&gt;% filter(測項==&quot;PM2.5&quot;) %&gt;% gather(&quot;hour&quot;, &quot;PM25&quot;, 4:28) %&gt;% mutate(PM25 = as.numeric(PM25)) %&gt;% drop_na() %&gt;% group_by(日期) %&gt;% summarize(avg = mean(PM25)) %&gt;% ungroup() %&gt;% mutate(year = lubridate::year(日期), month = lubridate::month(日期)) %&gt;% group_by(year, month) %&gt;% summarize(avg = mean(avg)) %&gt;% ungroup() Counting data by month and plotting to ensure the degree of data loss. aqi_data %&gt;% filter(測項==&quot;PM2.5&quot;) %&gt;% arrange(日期)%&gt;% gather(&quot;hour&quot;, &quot;PM25&quot;, 4:28) %&gt;% mutate(PM25 = as.numeric(PM25)) %&gt;% drop_na() %&gt;% group_by(日期) %&gt;% summarize(avg = mean(PM25)) %&gt;% ungroup() %&gt;% arrange(日期) %&gt;% mutate(year = lubridate::year(日期), month = lubridate::month(日期)) %&gt;% count(year, month) %&gt;% mutate(rn = row_number()) %&gt;% ggplot() + aes(rn, n) + geom_line() + theme_minimal() 科普小學堂-空氣中的懸浮粒子 台灣PM2.5三大面向：空汙現況多嚴重？要怪中國還是怪自己？ - 第 1 頁 - The News Lens 關鍵評論網 library(gghighlight) toplot %&gt;% mutate(month = as.character(month)) %&gt;% group_by(month) %&gt;% arrange(year) %&gt;% # mutate(diff = avg -first(avg), # month = as.character(month)) %&gt;% # ungroup() %&gt;% ggplot() + aes(year, avg, color = month) + geom_line() + # geom_point() + gghighlight(month %in% c(&quot;11&quot;, &quot;12&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) + theme_minimal() 22.1.2 Trending: Extreme value toplot2 &lt;- aqi_data %&gt;% arrange(日期)%&gt;% filter(測項==&quot;PM2.5&quot;) %&gt;% gather(&quot;hour&quot;, &quot;PM25&quot;, 4:28) %&gt;% mutate(PM25 = as.numeric(PM25)) %&gt;% drop_na() %&gt;% group_by(日期) %&gt;% summarize(avg = sum(PM25)/24) %&gt;% ungroup() %&gt;% mutate(year = lubridate::year(日期), month = lubridate::month(日期)) %&gt;% group_by(year, month) %&gt;% summarize(purple = sum(avg&gt;150), red = sum(avg&gt;54), orange = sum(avg&gt;35)) %&gt;% ungroup() toplot2 %&gt;% mutate(month = as.character(month)) %&gt;% group_by(month) %&gt;% arrange(year) %&gt;% ggplot() + aes(year, orange, color = month) + geom_line() + # geom_point() + gghighlight(month %in% c(&quot;11&quot;, &quot;12&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) + ylab(&quot;Days (PM25 &gt; 35) in one month&quot;) + theme_minimal() toplot3 &lt;- aqi_data %&gt;% arrange(日期)%&gt;% filter(測項==&quot;PM2.5&quot;) %&gt;% gather(&quot;hour&quot;, &quot;PM25&quot;, 4:28) %&gt;% mutate(PM25 = as.numeric(PM25)) %&gt;% drop_na() %&gt;% mutate(year = lubridate::year(日期), month = lubridate::month(日期)) %&gt;% filter(month %in% c(11, 12, 1, 2, 3)) toplot3 %&gt;% mutate(year = as.character(year)) %&gt;% ggplot() + aes(y=year, x=PM25) + geom_boxplot(fill=&quot;skyblue&quot;, alpha=0.2) + xlim(0, 200) + theme_minimal() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
